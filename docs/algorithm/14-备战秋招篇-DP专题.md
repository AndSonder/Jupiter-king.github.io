# 备战秋招篇-DP 专题

## 1. 01 背包问题

对于面试的话，其实掌握 01 背包和完全背包，就够用了，最多可以再来一个多重背包。

### 1.1 朴素动态规划

有 N 件物品和一个容量为 V 的背包。第 i 件物品的体积是 v[i]，价值是 w[i]。求解将哪些物品装入背包可使价值总和最大。

![picture 4](images/1e22ba04f456b35041f8600671c5d83210046db9ea1d327951b3f08576e58a5c.png)  

01 背包问题的状态表示是 `f(i, j)`，表示前 i 个物品，背包容量为 j 时的最大价值。它的属性是 Max， 也就是求最大值。对于 `f(i, j)`，可以将其分为两种情况，这样的分法是不重不漏的：

- 第 i 个物品不放入背包，那么 `f(i, j) = f(i - 1, j)`
- 第 i 个物品放入背包，那么 `f(i, j) = f(i - 1, j - v[i]) + w[i]`

所以，状态转移方程是：

$$
\text{f}(\text i, \text j) = \max(\text f(\text i - 1, \text j), \text f(\text i - 1, \text j - \text v[\text i]) + \text w[\text i])
$$

这里给一个简单的模板代码：

```cpp
int dp[N + 1][V + 1];
int v[N + 1], w[N + 1];

// 省略输入部分

memset(dp, 0, sizeof(dp));
for (int i = 1; i <= N; i++) {
    for (int j = 0; j <= V; j++) {
        dp[i][j] = dp[i - 1][j];
        if (j >= v[i]) {
            dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]);
        }
    }
}
```


### 1.2 优化空间复杂度

在朴素动态规划的基础上，可以发现，`f(i, j)` 只和 `f(i - 1, j)` 和 `f(i - 1, j - v[i])` 有关，也是说在 i 这个纬度上，只和 i - 1 有关，所以我们可以使用滚动数组的方式，将二维数组优化为一维数组。

但是这里需要注意一个问题，就是如果还是按照朴素版本的遍历方法，那么会出现 `f(j)` 会被 `f(j - v[i])` 更新，但是 j 是大于 j - v[i] 的，计算 j 的时候，j - v[i] 已经被更新过了，也就是说已经不是上一轮的值了，所以这里需要从大到小遍历。

接下来我们看看代码怎么写：

```cpp
int dp[V + 1]; // 一维数组
int v[N + 1], w[N + 1];

// 省略输入部分
memset(dp, 0, sizeof(dp));
for (int i = 1; i <= N; i++) {
    for (int j = V; j >= v[i]; j--) {
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
}
```

### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

这题是 01 背包问题的变种，我们可以将这个问题转化为背包问题，背包的容量为 sum / 2，每个物品的体积和价值都是 nums[i]，最后看看是否能够**刚刚好装满背包**。

这个问题的状态表示是 `f(i, j)`，表示前 i 个物品，背包容量为 j 时，是否可以刚刚好装满背包。它的属性是 True/False，也就是求是否存在解。

![picture 5](images/ee3a0d370fa85205267b01b11e9bc8c8ee27c18ca4200d0bd43bb59159ec8ecf.png)  

状态转移方程是：

$$
\text{f}(\text i, \text j) = \text{f}(\text i - 1, \text j) \text{ or } \text{f}(\text i - 1, \text j - \text{nums}[\text i])
$$

$\text{f}(\text i - 1, \text j - \text{nums}[\text i])$ 表示的是第 i 个物品放入背包，第 i 个物品如果可以恰好放入背包，那么 $\text{f}(\text i - 1, \text j - \text{nums}[\text i])$ 也应该是 True。

代码如下：

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        
        int sum = 0;
        int n = nums.size();
        for (auto a: nums) sum += a;
        if (sum % 2) return false;

        vector<int> dp(sum / 2 + 1);
        dp[0] = 1;
        for (int i = 0;i < n;i ++)
        {
            for (int j = sum / 2;j >= nums[i];j --)
            {
                dp[j] = max(dp[j], dp[j - nums[i]]);
            }
        }
        return dp[sum / 2] > 0;
    }
};
```

注意由于这里的状态表示是是否能够刚刚好装满背包，所以我们需要考虑下初始化的问题，当背包容量为 0 的时候，是可以刚刚好装满的，所以 `dp(0) = 1` 。

### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/description/)

有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

- 如果 x == y，那么两块石头都会被完全粉碎；
- 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头最小的可能重量 。如果没有石头剩下，就返回 0。

这题如果没见过真的很难想到是动态规划，所以动规还是要多写多见（Doge)


![picture 6](images/82f9ca53871a088ab181e7158f1ebe3428721e1b1fc1b58a09cf7dbf7f8aed85.png)  

首先我们先看看他的状态表示是什么，这里我们可以用一个背包问题来表示，我们可以将这个问题转化为背包问题，背包的容量为 sum / 2，每个物品的体积和价值都是 stones[i]，最后看看最多能装多少。可以看到转化后就是一个标注的 01 背包问题。

:::tip

为什么是看最多能装多少，而不是刚刚好装满呢？因为这里是求最后一块石头的最小重量，所以我们需要尽可能的装满背包，所以这里是求最多能装多少，装的最多也就是消掉最多。

:::

在最后我们还需要思考一下答案是什么，`dp[sum / 2]` 表示最多能装多少，也可以理解为把石头分为两堆，使得其中一堆的重量尽可能接近总重量的一半。另一堆的重量就是总重量减去这一堆的重量，也就是 `sum - dp[sum / 2]`。用较大的减去较小的，就是最后一块石头的最小重量。最终答案就是 `sum - 2 * dp[sum / 2]`。

下面我们来看看代码：

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int n = stones.size();
        int sum = 0;
        for (auto a: stones) sum += a;
        int target = sum / 2;
        vector<int> dp(target + 1);
        for (int i = 0;i < n;i ++)
        {
            for (int j = target;j >= stones[i];j --)
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
        }
        return sum - dp[target] - dp[target];
    }
};
```

### [2915. 和为目标值的最长子序列的长度](https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/description/)


给你一个下标从 0 开始的整数数组 nums 和一个整数 target 。

返回和为 target 的 nums 子序列中，子序列 长度的最大值 。如果不存在和为 target 的子序列，返回 -1 。

子序列 指的是从原数组中删除一些或者不删除任何元素后，剩余元素保持原来的顺序构成的数组。

这题和上面的题目[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)很像，但是这里是求最长的子序列，所以我们需要记录的是长度，而不是是否存在解。

状态表示是 `f(i, j)`，表示前 i 个物品，和为 j 时的最长子序列长度。它的属性是 Max，也就是求最大值。不过这里的最大值是长度，而不是价值。注意 01 背包接这类恰好装满的问题，我们需要考虑初始化的问题，当背包容量为 0 的时候，是可以刚刚好装满的，序列长度为 0，所以 `dp[0] = 0`。而且这里还需要考虑 `j-nums[i]` 是否在数组内，如果不在数组内，那么 `dp[j] = INT_MIN`, 为什么要是 INT_MIN 呢？因为这里是求最大值，如果不在数组内，那么就是不合法的，所以应该是负无穷。如果设置的比较小，因为每次 `dp[j] = max(dp[j], dp[j - nums[i]] + 1)`，万一被加到大于 0，那么就会出现错误。

:::note

这类恰好装满的问题，经常需要考虑初始化的问题，但并不是说其他的 01 背包问题就不需要初始化，比如朴素的 01 背包问题，我们也需要初始化，只不过初始化的值是 0。

:::

![picture 7](images/541d2187683e9cd653c018ef4c5c3a256583be82f992315c5e26f2cfff2a93c5.png)  


状态转移方程是：

$$
\text{f}(\text i, \text j) = max(\text{f}(\text i - 1, \text j), \text{f}(\text i - 1, \text j - \text{nums}[\text i]) + 1)
$$

代码如下：

```cpp
class Solution {
public:
    int lengthOfLongestSubsequence(vector<int>& nums, int target) {
        int n = nums.size();
        vector<int> dp(target + 1, INT_MIN);
        dp[0] = 0;
        for (int i = 0;i < n;i ++)
        {
            for (int j = target;j >= nums[i];j --)
                dp[j] = max(dp[j], dp[j - nums[i]] + 1);
        }
        return dp[target] > 0 ? dp[target] : -1;
    }
};
```

### [494. 目标和](https://leetcode.cn/problems/target-sum/description/)

给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

-   例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

这题在普通求目标和的基础上，给每个数添加了正负号，并且需要记录方案数，我们可以看到这里的本质还是求和为 target 的方案数。

![picture 8](images/0b4642bd2658b8378dcdd5a8aa7ed5b49b18e1a7ca90e66dac69ff25f2564ff5.png)  

状态表示是 `f(i, j)`，表示前 i 个物品，和为 j 时的方案数。它的属性是 Sum，也就是求和。在状态划分的时候，对于 `f(i, j)`，可以将其分为两种情况，也就是 i 取 `+nums[i]` 和 `-nums[i]`。因为这题里面是每个元素都要取的，这点和普通的 01 背包问题不一样。所以 `f(i, j)` 就可以由 `f(i - 1, j - nums[i])` 和 `f(i - 1, j + nums[i])` 转移过来。最终可以得到状态转移方程是：

$$
\text{f}(\text i, \text j) = \text{f}(\text i - 1, \text j - \text{nums}[\text i]) + \text{f}(\text i - 1, \text j + \text{nums}[\text i])
$$

这里需要注意由于 i 状态依赖于 i - 1 的状态, 但是是需要用到 `j - nums[i]` 和 `j + nums[i]` 的状态，所以这里我们就没办法使用滚动数组的方式来优化空间复杂度了，因为无论是从小到大还是从大到小，都会出现 `j - nums[i]` 和 `j + nums[i]` 的状态被更新的问题。

代码如下：

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int n = nums.size();
        int sum = 0;

        for (int i: nums) sum += i;

        if (abs(target) > sum) return 0;

        int offset = sum;
        vector<vector<int>> dp(n + 1, vector<int>(2 * sum + 1));

        dp[0][offset] = 1;
        for (int i = 1;i <= n;i ++)
        {
            for (int j = -sum;j <= sum;j ++)
            {
                if (j - nums[i - 1] >= -sum)
                    dp[i][j + offset] += dp[i - 1][j - nums[i - 1] + offset];
                if (j + nums[i - 1] <= sum)
                    dp[i][j + offset] += dp[i - 1][j + nums[i - 1] + offset];
            }
        }
        return dp[n][target + offset];
    }
};
```

这个题目里面还有一个小技巧，因为 target 的值可能是负数，所以我们需要有一个偏移量 offset，这样就可以将负数转化为正数，这样就可以使用数组来表示了。

### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/description/)

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

这题也是 01 背包 的一个变种，这题里面物品的体积有俩个维度，一个是 0 的个数，一个是 1 的个数，然后求的是最大的子集长度。

![picture 9](images/7b96977afeb75481b6b39c783af23c9ffd5168f84064a57139c69010ba1b9cde.png)  

状态表示是 `f(i, j, k)`，表示前 i 个物品，0 的个数为 j，1 的个数为 k 时的最大子集长度。它的属性是 Max，这里的最大值是长度，而不是价值，对应的我们的状态表示里面对应的也是长度。状态转移方程是：

$$
\text{f}(\text i, \text j, \text k) = \max(\text{f}(\text i - 1, \text j, \text k), \text{f}(\text i - 1, \text j - \text{zeros}[\text i], \text k - \text{ones}[\text i]) + 1)
$$

代码如下：

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int len = strs.size();

        vector<int> zero_count(len, 0);
        vector<int> one_count(len, 0);
        for (int i = 0;i < len;i ++)
        {
            auto s = strs[i];
            for (char c: s)
            { 
                if (c == '0') zero_count[i] ++;
                else if (c == '1') one_count[i] ++;
            }
        }

        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 1;i <= len;i ++)
        {
            int one_num = one_count[i - 1];
            int zero_num = zero_count[i - 1];
            for (int j = m;j >= zero_num;j --)
            {
                for (int k = n;k >= one_num;k --)
                {
                    dp[j][k] = max(dp[j][k], dp[j - zero_num][k - one_num] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

### 小结

通过这几道题目可以发现，01 背包的问题的变种基本都是 `判断是否可以刚刚好装满` 的问题。

比如，[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/) 其实就是求是否存在元素和刚刚好是 `sum/2`, [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/description/) 也是如出一辙。在 `是否刚刚好能装满的问题` 上还可以进一步变种，比如记录方案数 （[2915. 和为目标值的最长子序列的长度](https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/description/)）。在记录状态数的基础上，还可以进一步变种，比如 [494. 目标和](https://leetcode.cn/problems/target-sum/description/)，这里在记录方案数的基础上，还需要记录正负号。

万变不离其宗，遇到这类问题的解题目思路还是一样的，首先判断是不是 01 背包的问题，然后去想状态表示，然后再去想状态转移方程。最后再去考虑初始化的问题。

## 2. 完全背包问题

完全背包问题和 01 背包问题的区别在于，每个物品可以取无限次。

完全背包的状态表示和 01 背包一样，也是 `f(i, j)`，表示前 i 个物品，背包容量为 j 时的最大价值。它的属性是 Max，也就是求最大值。对于 `f(i, j)`，可以将其分为两种情况：

- 第 i 个物品不放入背包，那么 `f(i, j) = f(i - 1, j)`
- 第 i 个物品放入背包，那么 `f(i, j) = f(i, j - v[i]) + w[i]`

为什么第 i 个物品放入背包的时候，是 `f(i, j - v[i])` 而不是 `f(i - 1, j - v[i])` 呢？因为这里是完全背包问题，每个物品可以取无限次，所以还是取第 i 个物品，只是容量变为了 `j - v[i]`。

这里由于 `f(i, j - v[i])` 不在依赖于 i - 1，所以我们在把它优化成一维数组的时候，可以从小到大遍历。

模板代码如下：

```cpp
int dp[V + 1]; // 一维数组
int v[N + 1], w[N + 1];
// 省略输入部分
memset(dp, 0, sizeof(dp));
for (int i = 1; i <= N; i++) {
    for (int j = v[i]; j <= V; j++) {
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
}
```

### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

这题就是一个板子题，完全背包问题，每个硬币可以取无限次。但是这里的测试用力比较坑，虽然保证了有解的时候结果符合 32 位带符号整数，但是当没有解的时候，结果可能会超过 32 位带符号整数，所以我们需要做俩次动态规划，第一次是求是否有解，第二次是求解的个数。

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1), valid(amount + 1);

        dp[0] = 1;
        valid[0] = 1;
        for (int coin: coins)
        {
            for (int i = coin;i <= amount;i ++)
                valid[i] |= valid[i - coin];
        }
        if(!valid[amount]) return 0;

        for (int coin: coins)
        {
            for (int i = coin;i <= amount;i ++)
                dp[i] += dp[i - coin];
        }
        return dp[amount];
    }
};
```

### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/description/)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

![picture 9](images/d02ac17b14d3bb296954d657d5d1b70f6fafcd2ff8e24c6e9409df4c4bcbf98e.png)  

这题我们需要求的是和为 j 且硬币个数最少的方案数，所以我们需要初始化为 `INT_MAX`，这样在状态转移的时候，可以取最小值。状态表示 `f(i, j)` 还是表示前 i 个物品，和为 j 时的最少硬币个数。它的属性最小集合的大小，所以状态转移方程是：

$$
\text{f}(\text i, \text j) = \min(\text{f}(\text i - 1, \text j), \text{f}(\text i, \text j - \text{coins}[\text i]) + 1)
$$

代码如下：

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();

        vector<int> dp(amount + 1, INT_MAX - 1);
        dp[0] = 0;
        for (int coin: coins)
        {
            for(int i = coin;i <= amount;i ++)
                dp[i] = min(dp[i - coin] + 1, dp[i]);
        }
        return dp[amount] < INT_MAX - 1 ? dp[amount] : -1;
    }
};
```

#### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/description/)

给你一个整数 `n` ，返回和为 `n` 的完全平方数的最少数量。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

这题的思路和 [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/description/) 是一样的，只不过这里的硬币是完全平方数。我们可以先把完全平方数都找出来，然后再用完全背包的思路来做，比较简单这里就直接放代码了。

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> nums;
        int i = 0;
        while (i * i <= n)
        {
            nums.push_back(i * i);
            i ++;
        }

        int m = nums.size();
        vector<int> dp(n + 1, INT_MAX - 1);
        dp[0] = 0;

        for (int i = 0;i < m;i ++)
        {
            for (int j = nums[i]; j <= n;j ++)
                dp[j] = min(dp[j], dp[j - nums[i]] + 1);
        }

        return dp[n];
    }
};
```

### 小结

完全背包和 01 背包的区别在于，每个物品可以取无限次。题目的类型相比较 01 背包问题要少一些，思路相对来说比较简单一些。最常见的一类题目就是组合数的问题，比如 [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)，[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/description/)，[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/description/) 等他们本质上都是求组合数。

## 3. 多重背包问题

多重背包问题和 01 背包问题的区别在于，每个物品可以取多次。多重背包问题可以转换为 0/1 背包问题，我们只需要将每个物品的多次选择视为多个不同的物品，然后使用标准的 0/1 背包算法来解决就可以了。

假设有 3 个物品，分别为：

- 物品 1：重量 2，价值 3，可以放入背包最多 3 次。
- 物品 2：重量 3，价值 4，可以放入背包最多 2 次。
- 物品 3：重量 4，价值 5，可以放入背包最多 1 次。

并且有一个背包，容量为 8。我们可以将物品 1 拆分成 3 个物品，物品 2 拆分成 2 个物品，物品 3 拆分成 1 个物品，这样就可以转化为 0/1 背包问题。

- 物品 1 拆解为 3 个物品：（重量 2，价值 3）、（重量 2，价值 3）、（重量 2，价值 3）
- 物品 2 拆解为 2 个物品：（重量 3，价值 4）、（重量 3，价值 4）
- 物品 3 拆解为 1 个物品：（重量 4，价值 5）

这样就可以转化为 0/1 背包问题，然后使用标准的 0/1 背包算法来解决。

纯的多重背包，Leetcode 上没有，但是有用多重背包来解排列的问题，这个题目我们在下一个小结中再介绍。

## 4. 看起来像背包问题的排列问题

有一类题目，看起来像背包问题，但是实际上是排列问题。这类题目的特点是，每个物品可以取多次，但是取的顺序是有关系的，比如排列问题。

为什么背包不能解决排列问题呢？因为背包问题是求组合数，不能区分顺序，而排列问题是求排列数，需要区分顺序。

### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/description/)

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

这题一看起来你可能以为是一个完全背包问题，但是实陵上是一个排列问题。这里的状态表示是 `f(i)`，表示所有划分方案的集合。它的属性是集合中的元素数量。对于 `f(i)` 我们可以将其以 `nums[j]` 为结尾的所有方案的集合的和，状态转移方程是：

$$
\text{f}(\text i) = \sum_{\text j = 0}^{\text n} \text{f}(\text i - \text{nums}[\text j])
$$

![picture 10](images/2d31abc9550e1410f2f4c70e6c28241dee2820f10270ee00303beedea1f70872.png)  

代码如下：

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<unsigned> dp(target + 1);

        dp[0] = 1;
        for (int j = 0;j <= target;j ++)
            for (int num: nums)
            {
                if (j - num >= 0)
                    dp[j] += dp[j - num];
            }
        return dp[target];
    }
};
```

### [139.单词拆分](https://leetcode.cn/problems/word-break/description/)

给定一个**非空**字符串 *s* 和一个包含**非空**单词的列表 *wordDict*，判定 *s* 是否可以被空格拆分为一个或多个在字典中出现的单词。

这题其实和上面的题目是一样的，只不过这里的状态表示是 `f(i)`，表示前 i 个字符是否可以被拆分。它的属性是 True/False。对于 `f(i)` 我们同样可以将其以 `wordDict[j]` 为结尾的所有方案的集合的和。这题还有一个技巧，就是我们需要反复的比较 `wordDict[j]` 和 `s[i - wordDict[j].size(), i]` 是否相等，这里我们可以先使用一个哈希表来存储 `wordDict`，然后在遍历的时候从 n-1 到 0 遍历，这样在内层循环的时候，我们可以初始化一个空字符串 `ss`，每次循环的时候，我们就可以直接在这个字符串后面加上 `s[j]` ，这样直接查询哈希表是否存在这个字符串就可以了。


```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n = s.length();
        unordered_set<string> h;
        for (auto item: wordDict) h.insert(item);
        vector<int> dp(n + 1);

        dp[n] = 1;
        for (int i = n - 1;i >= 0;i --)
        {
            string ss = "";
            for (int j = i;j < n;j ++)
            {
                ss += s[j];
                // 如果 ss 在哈希表中，且 dp[j + 1] 为 True
                // 也就是 s[j + 1, n] 也可以被拆分
                // 那么 s[i, n] 也可以被拆分 => dp[i] = 1
                if (dp[j + 1] && h.count(ss))
                {
                    dp[i] = 1;
                    break;
                }
            }
        }
        return dp[0];
    }
};
```

## 5. 经典线性 DP

### 5.1 什么是线性 DP

线性 DP 是一种动态规划方法，其中每个状态的值仅依赖于前一个状态的值，而不依赖于更前面的状态。这种方法通过递推关系逐步计算出最终结果，通常用于解决具有线性结构的问题，如最长递增子序列、斐波那契数列等。

下面我们来看看一些经典的线性 DP 问题。

### 5.2 最长公共子序列（LCS）

一般来说，求两个字符串的最长公共子序列，我们可以使用动态规划来解决。这个问题的状态表示是 `f(i, j)`，表示 `text1[0, i]` 和 `text2[0, j]` 的最长公共子序列的长度。它的属性是 Max，也就是求最大值。对于 `f(i, j)`，我们可以将其分为两种情况：

- `text1[i] == text2[j]`，那么 `f(i, j) = f(i - 1, j - 1) + 1`
- `text1[i] != text2[j]`，那么 `f(i, j) = max(f(i - 1, j), f(i, j - 1))`

这个问题的状态转移方程是：

$$
\text{f}(\text i, \text j) = \begin{cases} \text{f}(\text i - 1, \text j - 1) + 1 & \text{if } \text{text1}[\text i] == \text{text2}[\text j] \\ \max(\text{f}(\text i - 1, \text j), \text{f}(\text i, \text j - 1)) & \text{if } \text{text1}[\text i] \neq \text{text2}[\text j] \end{cases}
$$


这里看起来和背包问题一样由于每次状态只依赖于前一个状态，但是这里并不能使用滚动数组来优化空间复杂度，因为我们需要用到 `f(i - 1, j - 1)` 和 `f(i, j - 1)` 的状态，所以我们还是需要使用二维数组来存储状态。



#### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

这题就是最长子序列的模板题，下面是代码：

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size();
        int m = text2.size();
        text1 = " " + text1;
        text2 = " " + text2;
        vector<vector<int>> dp(n + 1, vector<int>(m + 1));

        for (int i = 1;i <= n;i ++)
        {
            for (int j = 1;j <= m;j ++)
            {
                if (text1[i] == text2[j])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else 
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[n][m];
    }
};
```

#### [583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/description/)

给定两个单词 `word1` 和 `word2`，找到使得 `word1` 和 `word2` 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

这题和上面的题目基本是一样的，但是我们需要多考虑一些情况，这题里面有可能 word1 和 word2 是一样的情况，这个时候我们就不需要删除了，直接返回 0，如果 word1 和 word2 每个字符都不一样，那么我们就需要删除所有的字符，所以返回 `n + m`。要怎么才能兼顾考虑这俩种情况呢？我们可以先求出最长公共子序列的长度，然后用 `n + m - 2 * lcs` 就可以了。

为什么是 `n + m - 2 * lcs` 呢？因为我们需要删除的字符数是 `n - lcs` 和 `m - lcs`，所以总共需要删除的字符数是 `n + m - 2 * lcs`。

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();

        word1 = " " + word1;
        word2 = " " + word2;

        vector<vector<int>> dp(n + 1, vector<int>(m + 1));

        for (int i = 1; i <= n; i ++)
        {
            for (int j = 1; j <= m;j ++)
            {
                if (word1[i] == word2[j])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else
                    dp[i][j] = max(dp[i - 1][j], dp[i][ j - 1]);
            }
        }
        return n + m - 2 * dp[n][m];
    }
};
```

类似的题目还有 [712. 两个字符串的最小 ASCII 删除和](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/description/)，这题和上面的题目基本一样，只不过我们需要求的是删除字符的 ASCII 码的和。

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/description/)

给你两个单词 `word1` 和 `word2`，请你计算出将 `word1` 转换成 `word2` 所使用的最少操作数。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

这题比较经典，我们可以使用动态规划来解决。这个问题的状态表示是 `f(i, j)`，表示 `word1[0, i]` 和 `word2[0, j]` 的最小操作数。它的属性是 Min，也就是求最小值。对于 `f(i, j)`，我们可以将其分为俩种情况：

- `word1[i] == word2[j]`，那么 `f(i, j) = f(i - 1, j - 1)`
- `word1[i] != word2[j]`，那么 `f(i, j) = min(f(i - 1, j), f(i, j - 1), f(i - 1, j - 1)) + 1`

- `f(i - 1, j)` 表示删除 `word1[i]`
- `f(i, j - 1)` 表示插入 `word2[j]`
- `f(i - 1, j - 1)` 表示替换 `word1[i]` 为 `word2[j]`

为什么这个问题可以分解到只考虑“最后一位字符”的操作？

想象一下，`A[1..i]` 要变成 `B[1..j]`，最终达成匹配的那一刻有且只有两种情况：

1. A[i] 与 B[j] 已经是相同的字符，此时不需要对 A[i] 或 B[j] 再进行任何修改，那么最终的编辑次数就等于将 A[1..i-1] 变成 B[1..j-1] 的编辑次数 f[i-1][j-1]
2. A[i] 与 B[j] 不同或者不匹配，需要通过一次“操作”来让最终的状态达成一致

重点是，任何一个将 A[1..i] 变为 B[1..j] 的最优编辑方案的“最后一步”一定涉及到 A[i] 和/或 B[j]。为什么？因为当你完成了整个转换，A 和 B 最终对齐匹配，其中最后一个字符位置的关系，是最直观、最底层的分界。

让我们从最后一步入手，把所有的可能性细分：

1. 情况 1：增加操作
假设最后一步是“在 A 的末尾增加一个字符”，以使得 A[1..i] 变成了 B[1..j]。如果最后一步是增加，那么增加的一定是 B[j]，因为你最终想匹配到 B 的末尾。这时，在增加 B[j] 之前，你的 A[1..i] 应该已经与 B[1..j-1]匹配了。所以此时的编辑距离是：f[i][j] = f[i][j-1] + 1（先把 A[1..i] 变成 B[1..j-1]，然后再增加一个字符 B[j]，总步数 = 前面步骤数 + 1）
2. 情况 2：删除操作
假设最后一步是从 A 中删除掉它的最后一个字符 A[i]，这样才能与 B[1..j]匹配。
如果要删除 A[i]，那么在删除之前 A[1..i-1] 一定已经与 B[1..j] 匹配了。
所以 f[i][j] = f[i-1][j] + 1。
3. 情况 3：替换操作
假设最后一步是对 A[i] 进行替换，使它变成 B[j]。
那么在替换前，A[1..i-1] 与 B[1..j-1] 已经匹配完成。然后再将 A[i] 改成 B[j]，
所以 f[i][j] = f[i-1][j-1] + 1。（如果 A[i] != B[j]）
4. 情况 4：什么都不做
如果最后一个字符已经匹配（A[i] == B[j]），那么根本不需要对最后一位进行增删改操作。
此时 f[i][j] = f[i-1][j-1]。（+0 操作，因为已经匹配好了）

通过这四种情况，我们将“最后一步操作”这个问题进行完整划分。增、删、改、或无需操作，这四种情况不重不漏地覆盖了所有可能的编辑方式。

关键点在于, 无论你的最优解原本是在哪个位置动手操作的，因为操作的独立性和可交换性（不影响最终编辑距离），你总能将最后一步安排在 A[i] 和 B[j] 的位置。这样，我们就可以放心地只考虑对 A[i]、B[j] 末尾字符的操作。

每次处理最后那个待匹配字符”的流程。就像搭积木一样：要让前 i 个积木搭成与另一堆前 j 块一样的造型，你不是最后再去动中间的积木，因为如果中间没对齐，你早就应该前面阶段就把它对齐了。从整体到局部，再从局部到最后一块，所有中间步骤加上合理的重排，都可以抽象为在解决 f[i][j] 时，对最后一块拼上、拆下或者改一下。

前面都分析清楚了之后，我们就可以写出状态转移方程了：

$$
\text{f}(\text i, \text j) = \begin{cases} \text{f}(\text i - 1, \text j - 1) & \text{if } \text{word1}[\text i] == \text{word2}[\text j] \\ \min(\text{f}(\text i - 1, \text j), \text{f}(\text i, \text j - 1), \text{f}(\text i - 1, \text j - 1)) + 1 & \text{if } \text{word1}[\text i] \neq \text{word2}[\text j] \end{cases}
$$

此外我们还需要考虑初始化的问题，当 `i = 0` 或者 `j = 0` 的时候，我们需要初始化 `f(i, j)` 的值，这个时候 `f(i, j)` 的值就是 `i` 或者 `j`。因为当 `i = 0` 的时候，`word1[0, 0]` 为空字符串，所以我们需要删除 `j` 个字符，所以 `f(0, j) = j`。同理，当 `j = 0` 的时候，`f(i, 0) = i`。

代码如下：

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.size();
        int m = word2.size();

        word1 = " " + word1;
        word2 = " " + word2;

        vector<vector<int>> dp(n + 1, vector<int>(m + 1));

        for (int i = 0;i <= n;i ++)
            dp[i][0] = i;
        for (int i = 0;i <= m;i ++)
            dp[0][i] = i;

        for (int i = 1;i <= n;i ++)
        {
            for (int j = 1;j <= m;j ++)
            {
                if (word1[i] == word2[j])
                    dp[i][j] = dp[i - 1][j - 1];
                else
                    dp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
            }
        }
        return dp[n][m];
    }
};
```

#### [97. 交错字符串](https://leetcode-cn.com/problems/interleaving-string/description/)

给定三个字符串 `s1`、`s2`、`s3`，请你帮忙验证 `s3` 是否是由 `s1` 和 `s2` 交错组成的。

交错字符串的定义如下：`s3` 是由 `s1` 和 `s2` 交错组成的当且仅当可以通过 `s1` 和 `s2` 的所有字符按顺序构成 `s3`，且对于所有的字符，`s1` 和 `s2` 中每种字符的出现次数都保持不变。

![picture 11](images/9c75a12d987726f9926a7a47892a81479b5847c92e5b1e08f16657c78f5bd729.png)  

我们首先来看看这个问题的状态表示，这个问题的状态表示是 `f(i, j)`，表示 `s1[0, i]` 和 `s2[0, j]` 是否可以交错组成 `s3[0, i + j]`。它的属性是 True/False。对于 `f(i, j)`，我们可以将其分为俩种情况：

- s3[i + j] == s1[i]，那么 `f(i, j) = f(i - 1, j)`
- s3[i + j] == s2[j]，那么 `f(i, j) = f(i, j - 1)`

代码实现如下：

```cpp
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int n = s1.size(), m = s2.size(), k = s3.size();
        if (n + m != k) return false;
        s1 = " " + s1, s2 = " " + s2, s3 = " " + s3;

        vector<vector<int>> dp(n + 1, vector<int>(m + 1));
        dp[0][0] = 1;

        for (int i = 0;i <= n;i ++)
        {
            for (int j = 0; j <= m;j ++)
            {
                if (i && dp[i - 1][j] && s1[i] == s3[i + j])
                    dp[i][j] = 1;
                else if (j && dp[i][j - 1] && s2[j] == s3[i + j])
                    dp[i][j] = 1;
            }
        }
        return dp[n][m];
    }
};
```

注意这里 s1 或者 s2 是可能为空字符串的，所以我们需要初始化 `dp[0][0] = 1`，而且遍历的时候，我们需要考虑 `i` 或者 `j` 为 0 的情况。

#### [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/description/)

在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。

现在，我们可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足满足：

- `nums1[i] == nums2[j]`
- 且线不重叠

请注意，满足上述要求的直线可能不存在。

返回两个列表中可以绘制的最长不相交直线的数量。

这题其实就是求最长公共子序列，代码一点都没有变，这里就不放代码了。

#### [1092. 最短公共超序列](https://leetcode-cn.com/problems/shortest-common-supersequence/description/)

给出两个字符串 `str1` 和 `str2`，返回同时以 `str1` 和 `str2` 作为子序列的最短字符串。如果答案不唯一，则可以返回满足条件的任意一个答案。

如果从字符串 t 中删除一些字符（也可能不删除），可以得到字符串 s，那么 s 就是 t 的一个子序列。

其实这一类问题最重要的就是要把他转换成一个最长公共子序列的问题，这样就可以直接套用上面的模板了。我们来看看这题用最长公共子序列的思路要如何解决。

首先我们需要求出 `str1` 和 `str2` 的最长公共子序列的长度，然后根据 DP 数组的信息，我们可以反推出俩个字符串的最长公共子序列。然后我们就可以发现，只要把 `str1` 和 `str2` 非公共的字符插入到最长公共子序列中，就可以得到一个最短的公共超序列。

代码如下：

```cpp
class Solution {
public:
    string shortestCommonSupersequence(string str1, string str2) {
        int n = str1.size(), m = str2.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1));

        // Step 1: Compute the LCS using DP
        for (int i = 1;i <= n;i ++)
        {
            for (int j = 1;j <= m;j ++)
            {
                if (str1[i- 1] == str2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        // Step 2: Backtrack to find the LCS
        string lcs;
        int i = n, j = m;
        while (i > 0 && j > 0)
        {
            if (str1[i - 1] == str2[j - 1])
            {
                lcs.push_back(str1[i - 1]);
                i --, j --;
            } else if (dp[i - 1][j] > dp[i][j - 1])
            {
                i --;
            } else
            {
                j --;
            }
        }
        reverse(lcs.begin(), lcs.end());

        // Step 3: Construct the shortest common supersequence
        i = j = 0;
        string res = "";
        for (char c: lcs)
        {
            while (i < str1.size() && str1[i] != c)
                res.push_back(str1[i ++]);
            while (j < str2.size() && str2[j] != c)
                res.push_back(str2[j ++]);
            res.push_back(c);
            i ++, j ++;
        }

        for (;i < str1.size();i ++) res.push_back(str1[i]);
        for (;j < str2.size();j ++) res.push_back(str2[j]);
        return res;
    }
};
```

#### 小结

LCS 的核心是：在两个序列中找到最大匹配的子序列，且必须保持相对顺序。

一旦你发现题目满足以下特点，大概率可以直接套用 LCS 模板：

1. 双序列：题目提供两个序列（字符串、数组等），并让你在两者间找“公共”或“相似”的部分。
2. 相对顺序：子序列的顺序不能被打乱，但不要求连续。
3. 最大化或最小化：通常是找最长的公共部分，或者计算最少的修改/操作次数。
4. 允许调整：比如通过插入、删除、替换等方式，让两序列“对齐”。

:::tip

双序列，顺序在，求长短，可动态

:::

当题目让你在两个序列中找“共同部分”、优化某种代价时，试着问自己：

- “双序列，顺序不乱”：两个序列是否需要相对顺序？
- “动态有解”：问题是否能拆分成子问题，用 DP 解决？


### 5.3 最长递增子序列（LIS）

最长递增子序列（Longest Increasing Subsequence，简写 LIS）是一个非常经典的问题。所谓最长递增子序列是指，在一个序列中，找到一个最长的子序列，使得这个子序列是严格递增的。

#### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

这题就是最长递增子序列的模板题，我们可以使用动态规划来解决。这个问题的状态表示是 `f(i)`，表示 `nums[0, i]` 的最长递增子序列的长度。它的属性是 Max，也就是求最大值。对于 `f(i)`，我们可以将其分为 `i` 种情况，也就是 `nums[i]` 可以作为最长递增子序列的最后一个元素，那么 `f(i)` 就是 `f(j) + 1`，其中 `j` 是所有小于 `i` 的元素中，`nums[j] < nums[i]` 的最大值。

下面我们来看看代码：

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();

        vector<int> dp(n + 1);
        for (int i = 1;i <= n;i ++)
        {
            for (int j = 1;j <= i;j ++)
            {
                if (nums[i - 1] > nums[j - 1])
                    dp[i] = max(dp[i], dp[j]);
            }
            dp[i] += 1;
        }
        int ans = 0;
        for (int i = 1;i <= n;i ++)
            ans = max(ans, dp[i]);
        return ans;
    }
};
```

注意这里的答案是 `dp[i]` 中的最大值，而不是 `dp[n]`，因为 `dp[i]` 表示的是 `nums[0, i]` 的最长递增子序列的长度，所以我们需要遍历一遍 `dp` 数组，找到最大值。

#### [2826. 将三个组排序](https://leetcode.cn/problems/sorting-three-groups/description/)

给你一个整数数组 nums 。nums 的每个元素是 1，2 或 3。在每次操作中，你可以删除 nums 中的一个元素。返回使 nums 成为 `非递减` 顺序所需操作数的 `最小值`。

这题其实就是最长递增子序列的变种题，但是这里我们需要注意一下，如果要让 `nums` 成为非递减顺序，那么我的动态规划条件就是 `nums[i] >= nums[j]`，而不是 `nums[i] > nums[j]`。这里我们需要注意一下。最后的 daan 就是 `n - LIS`。

```cpp
class Solution {
public:
    int minimumOperations(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n + 1);
        int ans = 0;
        for (int i = 1;i <= n;i ++)
        {
            for (int j = 1;j <= n;j ++)
            {
                if (nums[i - 1] >= nums[j - 1])
                    dp[i] = max(dp[i], dp[j]);
            }
            dp[i] += 1;
            ans = max(ans, dp[i]);
        }

        return n - ans;
    }
};
```

#### [1671. 得到山形数组的最少删除次数](https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/description/)

我们定义 `arr` 是 山形数组 当且仅当它满足：

- `arr.length >= 3`
- 存在某个下标 `i` （从 `0` 开始） 满足 `0 < i < arr.length - 1` 且：
  - `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`
  - `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`

给你整数数组 `nums` ，请你返回将 `nums` 变成 山形状数组 的最少删除次数。

这题如果不会最长递增子序列，那真是写不了一点，首先我们先看下什么是山形数组，山形数组就是一个数组，它的前半部分是递增的，后半部分是递减的。那么我们可以在俩个方向上分别求出最长递增子序列，然后遍历每个位置 i，把俩个方向的最长递增子序列相加，然后用 n 减去这个值就是答案在这个位置的最小删除次数。最后我们遍历一遍所有的位置，找到最小的删除次数。

```cpp
class Solution {
public:
    int minimumMountainRemovals(vector<int>& nums) {
        int n = nums.size();
        vector<int> f1(n + 1);
        vector<int> f2(n + 1);

        for (int i = 1;i <= n;i ++)
        {
            for (int j = 1;j <= i;j ++)
            {
                if (nums[i - 1] > nums[j - 1])
                    f1[i] = max(f1[i], f1[j]);
            }
            f1[i] += 1;
        }

        for (int i = n; i >= 1;i --)
        {
            for (int j = n;j >= i;j --)
            {
                if (nums[i - 1] > nums[j - 1])
                    f2[i] = max(f2[i], f2[j]);
            }
            f2[i] += 1;
        }

        int ans = INT_MAX;
        for (int i = 2;i < n;i ++)
        {
            if (f1[i] > 1 && f2[i] > 1)
                ans = min(ans, n - f1[i] - f2[i] + 1);
        }

        return ans;
    }
};
```

#### [1626. 无矛盾的最佳球队](https://leetcode.cn/problems/best-team-with-no-conflicts/description/)

假设你是球队的经理。对于即将到来的比赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 总和 。

然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 `没有矛盾` 的球队。如果一名年龄较小球员的分数 `严格大于` 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。

给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。请你返回 所有可能的无矛盾球队中得分最高那支的分数 。

这题的类型是排序 + 动态规划。我们对球员按照分数进行排序，如果分数相同就按照年龄进行排序。

比如 scores = [4,5,6,5], ages = [2,1,2,1] 排序之后就是：

```plain
(4, 2), (5, 1), (5, 1), (6, 2)
```

答案就是 5 + 5 + 6 = 16。可以观察到这个问题就被转化为了一个最长递增子序列的问题。我们求一个最长递增子序列，使得年龄是递增的，然后把这个最长递增子序列的分数相加就是答案。

```cpp
class Solution {
public:
    int bestTeamScore(vector<int>& scores, vector<int>& ages) {
        int n = scores.size();
        vector<pair<int, int>> a(n);
        for (int i = 0;i < n;i ++)
            a[i] = {scores[i], ages[i]};
        sort(a.begin(), a.begin() + n);

        vector<int> dp(n + 1);
        for (int i = 0;i < n;i ++)
        {
            for (int j = 0;j < i;j ++)
            {
                if (a[j].second <= a[i].second)
                    dp[i] = max(dp[i], dp[j]);
            }
            dp[i] += a[i].first;
        }
        return *max_element(dp.begin(), dp.begin() + n);
    }
};
```

#### 小结

LIS 的核心是：在一个序列中找到最长的子序列，使得这个子序列是严格递增的。

一旦你发现题目满足 “给你一条序列”，并要求在这条序列上找一个满足某种单调性（一般是递增/非递减/递减/非递增）的子序列 “最长/最短/最多/最少” 时，大概率可以直接套用 LIS 模板。

LCS vs. LIS：

- 如果有两条序列、或者题意就是“公共子序列”之类关键词，就往 LCS 思路走
- 如果题干只有一条序列且在说“递增 / 递减 / 保留子序列单调性”，就往 LIS 思路靠


## 6. 状态机 DP

**什么是“状态”？**

状态是描述系统在某一时刻的具体情况。想象一下，你玩一个游戏，每一时刻你的游戏角色都有不同的情况，比如位置、是否有钥匙、生命值等。这些具体的情况就是状态。

**什么是“状态机”？**

状态机是一种工具，用于描述系统如何从一个状态转移到另一个状态。它类似于一个地图，展示了不同状态之间的连接和转移规则。

想象你在一个建筑里，每个房间代表一个状态，门代表你从一个房间（状态）到另一个房间（状态）的转移。

例如：

- 房间 A：你在起点。
- 房间 B：你拿到了钥匙。
- 房间 C：你打开了大门。

你可以从 A 通过拿钥匙进入 B，然后从 B 通过打开大门进入 C。

状态机 DP 结合了状态机和 **动态规划（DP）** 的思想，用于解决那些涉及多个状态和状态转移的复杂问题。它通过定义所有可能的状态及其转移方式，逐步计算出问题的最优解。

一般定义 f[i][j] 表示前缀 a[:i] 在状态 j 下的最优解，一般 j 很小。 

**为什么需要状态机 DP？**

有些问题不仅仅是线性推进的，而是涉及到多个条件或阶段，每个阶段可能有不同的状态和选择。状态机 DP 可以系统地处理这些多状态和多转移的情况。 它不像线性 DP 那样只考虑当前状态和前一个状态，而是考虑了更多的状态和转移。

### 6.1 买卖股票的最佳时机系列

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

这题是一个典型的状态机 DP 问题，我们可以定义 `f[i][j]` 表示第 `i` 天的状态是 `j` 的最大利润。其中 `j` 有俩种状态，一种是持有股票，一种是不持有股票。对于 `f[i][0]`，我们可以从 `f[i - 1][0]` 和 `f[i - 1][1] + prices[i]` 转移过来，对于 `f[i][1]`，我们可以从 `f[i - 1][1]` 和 `f[i - 1][0] - prices[i]` 转移过来。

![picture 12](images/30184adc94e2c475e639f1c36ad1cf0bb9096c1c33abe02c8d8779bc398a5115.png)  

下面我们考虑一下初始化的问题，当 `i = 0` 的时候，`f[0][0]` 就是 0，`f[0][1]` 就是 `-prices[0]` 或者是 `-INF` 也行主要目的就是确保不会从 `f[0][1]` 转移到其他状态。代码如下：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n + 1, vector<int>(2));

        dp[0][0] = 0;
        dp[0][1] = INT_MIN;

        for (int i = 1;i <= n;i ++)
        {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i - 1]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1]);
        }
        return dp[n][0];
    }
};
```

#### [309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

给定一个整数数组 prices，其中第  prices[i] 表示第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）

这题和上一题的区别就是多了一个冷冻期，我们还是可以定义 `f[i][j]` 表示**前** `i` 天的状态是 `j` 的最大利润。 但是对于 `f[i][1]` 的转移方程就有所不同了，我们可以从 `f[i - 1][1]` 和 `f[i - 2][0] - prices[i]` 转移过来。代码如下：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n + 2, vector<int>(2));

        dp[1][1] = INT_MIN;
        for (int i = 0;i < n;i ++)
        {
            dp[i + 2][0] = max(dp[i + 1][0], dp[i + 1][1] + prices[i]);
            dp[i + 2][1] = max(dp[i + 1][1], dp[i][0] - prices[i]);
        }
        return dp[n + 1][0];
    }
};
```

#### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

这题在上一题的基础上加了一个交易次数的限制，我们可以定义 `f[i][j][k]` 表示**前** `i` 天，最多交易 `j` 次的状态是 `k` 的最大利润。其中 `k` 有俩种状态，一种是持有股票，一种是不持有股票。 

对于 `f[i][j][0]`，我们可以从 `f[i - 1][j][0]` 和 `f[i - 1][j][1] + prices[i]` 转移过来，对于 `f[i][j][1]`，我们可以从 `f[i - 1][j][1]` 和 `f[i - 1][j - 1][0] - prices[i]` 转移过来。这里需要注意 i 是从 0 开始的，表示 prices 的索引，而 j 是从 1 开始的，表示交易次数。为了避免 i - 1 为负数，我们让 i 从 1 开始，相对应的 j 要从 2 开始。

我们还需要考虑一下初始化的问题，当 `i = 0` 的时候，`f[0][k][0]` 就是 0，`f[0][k][1]` 就是 `-prices[0]` 或者是 `-INF` 。

代码如下：

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        vector<vector<vector<int>>> f(n + 1, vector<vector<int>>(k + 2, vector<int>(2, INT_MIN / 2)));
        for (int j = 1;j <= k + 1;j ++)
            f[0][j][0] = 0;

        for (int i = 0;i < n;i ++)
        {
            for (int j = 1;j <= k + 1;j ++)
            {
                f[i + 1][j][0] = max(f[i][j][0], f[i][j][1] + prices[i]);
                f[i + 1][j][1] = max(f[i][j][1], f[i][j - 1][0] - prices[i]);
            }
        }
        return f[n][k + 1][0];
    }
};
```

























