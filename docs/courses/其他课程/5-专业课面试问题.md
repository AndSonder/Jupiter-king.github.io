# 专业课面试问题-数据结构

:::note
1、O(n)的大O是什么意思？什么是时间复杂度? ★★★
:::

O是描述函数渐进行为的数学符号，O(n)表示函数的数量级的渐进上界， 时间复杂度描述的是一个函数，这个函数可以定性描述该算法的运行时间

:::note
2、线性存储结构和链式存储结构的优点★★★
:::

线性存储结构的有点是查询速度快，缺点是存储空间的利用率不高

链式存储的优点是空间利用率高，缺点是查询速度慢

:::note
3、解释一下顺序存储与链式存储★★★
:::

顺序存储是将数据存储在连续的空间当中，链式存储将数据离散的存储在空间当中

:::note
4、头指针和头结点的区别？★★
:::

头结点是为了操作的统一与方便而设立的，放在第一个元素结点之前，其数据域一般无意义。 头指针就是一个指针，指向链表的头部

:::note
5、栈和队列的区别和内存结构★★★
:::

栈是先进后出，队列是先进先出

:::note
6、有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，如何求Q中元素的个数？★★
:::

假设循环队列的队尾指针是rear，队头是front，其中QueueSize为循环队列的最大长度。

(1) 入队时队尾指针前进1：(rear+1)%QueueSize

(2) 出队时队头指针前进1：(front+1)%QueueSize

(3) 队列长度：(rear-front+QueueSize)%QueueSize

现有一循环队列，其队头指针为front，队尾指针为rear；循环队列长度为N。其队内有效长度为？(假设队头不存放数据)

答案：(rear-front+N)%N

:::note
7、如何区分循环队列是队空还是队满？★★★
:::

① 少用一个空间，在队尾处空出来一个不使用

② 额外进行计数，在入队和出队前用一个变量对数量进行计数

:::note
8、堆、大顶堆、小顶堆实现及应用 ★★
:::

:::note
9、哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？★★★★
:::

:::note
**10、判断链表是否有环（非常重要！）★★★★★★★**
:::

使用快慢指针的算法，一个指针走的比较快，一个指针走的比较慢，如果链表有环则这两个指针一定会相遇，否则不会相遇；

:::note
11、平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造★★★
:::

平衡二叉树：任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。

构造平衡二叉树的时候在插入数据的时候按照二叉搜索树的方式插上，插入之后检查是否失衡，也就是检测有没有节点左右字数的高度差大于1，如果有的话就对最小失衡数进行旋转调整。

二叉排序树和二叉搜索树是一个东西，满足对于任何一个节点来说，其左节点的值都小于它的值，右节点的值都大于它的值。正常的情况下，查找的时间复杂度为 O（logn）。但是在计算情况下二叉搜索树的时间复杂度会变成 O(n)

完全二叉树是一种二叉树，其的每一个节点都有0个或者两个孩子节点

:::note
12、如何由遍历序列构造一颗二叉树？/已知先序序列和后序序列能否重现二叉树？（笔试经常考）★★★
:::

由先序遍历序列我们可以立刻确定根节点，那么在中序遍历序列中，我们定位这个找出来的根节点，该结点以左就是它的左子树，该结点以右就是它的右子树。递归的进行这个过程即可重建二叉树

已知先序遍历和后序遍历是不能唯一确定一颗二叉树的，这是因为前序和后序在本质上都是将父节点与子结点进行分离，但并没有指明左子树和右子树的能力，因此得到这两个序列只能明确父子关系，而不能确定一个二叉树。 

:::note
13、B树是什么?在数据库中有什么应用？（B数和B+树的区别）★★★
:::

B数是一种数据结构，提供排序数据，允许按排序顺序进行搜索、循序存取、附件和删除的功能。

一颗m阶的B树满足如下的条件：

1. 每个结点至多有m个子树
2. 除了根结点外每个节点至少有 $\lceil m / 2\rceil$ 个子树
3. 根结点至少有两棵子树 (除非 $B$ 树只包含一个结点)。所有叶结点在同一层上。B树的叶结点可以看成一种 外部结点, 不包含任何信息。
4. 有 $\mathrm{j}$ 个孩子的非叶结点恰好有 $\mathrm{j}-1$ 个关键码, 关键码按递增次序排列。

为什么文件查询要用B数而不用二叉搜索树？

如果单单从比较次数看的话，二叉查找树确实不比 B 树差，不过你忽略了一个很重要的点，那就是磁盘的寻址加载次数。

我们知道，在把磁盘里的数据加载到内存中的时候，是以页为单位来加载的，而节点与节点之间的数据是不连续的，所以不同的节点，很有可能分布在不同的磁盘页中。但是内存的运算速度是非常快的，至少比磁盘的寻址加载速度，快了几百倍，而我们进行数值比较的时候，是在内存中进行的，虽然 B 树的比较次数可能比二叉查找树多，但是磁盘操作次数少，所以总体来说，还是 B 树快的多，这也是为什么我们用使用 B 树来存储的原因。

:::note
14、红黑树相关★★★
:::

为什么有了平衡二叉树还需要红黑树？

虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。 显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣。

红黑树相比于BST和AVL树有什么优点？

红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。 

相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。

红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，AVL在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据.如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的。

:::note
**15、插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序（必考）、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）★★★★★★**
:::

```
1. 排序的基本概念
(1) 内排序和外排序
(2) 算法的稳定性
2. 插入排序
	(1) 直接插入排序
		a. 时间复杂度
			[1] 最好情况：O(n)
			[2] 平均情况：O(n^2)
			[3] 最坏情况：O(n^2)
		b. 辅助空间复杂度
			O(1)
		c. 稳定
	(2) 折半插入排序
		a. 时间复杂度
			[1] 最好情况：O(n)
			[2] 平均情况：O(n^2)
			[3] 最坏情况：O(n^2)
		b. 辅助空间复杂度
			O(1)
		c. 稳定
3. 冒泡排序（bubble sort）
	(1) 时间复杂度
		a. 最好情况：O(n)
		b. 平均情况：O(n^2)
		c. 最坏情况：O(n^2)
	(2) 空间复杂度
		O(1)
	(3) 稳定
4. 简单选择排序
	(1) 时间复杂度
		a. 最好情况：O(n^2)
		b. 平均情况：O(n^2)
		c. 最坏情况：O(n^2)
	(2) 空间复杂度
		O(1)
	(3) 不稳定
5. 希尔排序（shell sort）
	(1) 时间复杂度
		O(n^(3/2))
	(2) 空间复杂度
		O(1)
	(3) 不稳定
6. 快速排序
	(1) 时间复杂度
		a. 最好情况：O(nlogn)
		b. 平均情况：O(nlogn)
		c. 最坏情况：O(n^2)
	(2) 空间复杂度
		O(logn)
	(3) 不稳定
7. 堆排序
	(1) 时间复杂度
		a. 最好情况：O(nlogn)
		b. 平均情况：O(nlogn)
		c. 最坏情况：O(nlogn)
	(2) 空间复杂度
		O(logn)
	(3) 不稳定
8. 二路归并排序（merge sort）
	(1) 时间复杂度
		a. 最好情况：O(nlogn)
		b. 平均情况：O(nlogn)
		c. 最坏情况：O(nlogn)
	(2) 空间复杂度
		O(n)
	(3) 稳定
```

:::note
16、最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？（必考）★★★★★★★
:::

最小生成树用Prim算法实现， 最短路径可以用Dijtskra、spfa、bellman-fold等算法实现

Dijtskra可以用堆来优化寻找最短路径的时间

:::note
17、介绍一下深度优先搜索和广度优先搜索是如何实现的？★★★
:::

深度优先搜索基于递归/栈去实现，特点是一条路走到头，走到死胡同后在折返

广度优先搜索基于队列去实现，特点是在走每一步的时候将所有的情况都添加到队列当中

:::note
18、介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）★★★
:::

朴素匹配算法就是暴力匹配，根据字符串的长度用一个滑窗来匹配判断

KMP算法是一种快速字符串匹配算法，在每次失配时，不是把字符串往后移一位，而是把字符串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。

