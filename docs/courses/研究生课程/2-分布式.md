# 分布式系统复习

## 第一章

### 1.1 分布式系统的构建原因

1. **提高性能**：分布式系统可以利用多台计算机的并行处理能力，提高系统的吞吐量和响应速度。
2. **提高可靠性**：分布式系统可以通过冗余和容错机制，提高系统的可用性和容错性，避免单点故障。
3. **提高可扩展性**：分布式系统可以通过动态添加或删除节点，提高系统的可扩展性和灵活性，适应不同的负载需求。
4. **提高安全性**：分布式系统可以通过加密和认证技术，提高系统的安全性和保密性，防止数据泄露和攻击。

### 1.2 分布式系统的定义、特征

**定义：** 由多个自治的处理单元通过计算机网络互连并协作完成共同的任务的系统。

**特征：** 

- 并发性：多个程序（进程，线程）并发执行，共享资源
- 无全局时钟：每个机器有各自的时间，难以精确同步，程序间的协调靠交换消息
- 故障独立性：一些进程出现故障，并不能保证其它进程都能知道

### 1.3 分布式系统举例

1. **WEB搜索：** Google 最大最复杂的分布式系统之一
2. **大型多人在线游戏：** 王者荣耀 / 魔兽
3. **区块链系统：**比特币，分布式账本、不可篡改

### 1.4 分布式系统的挑战

1. **异构性**：分布式系统中的不同组件可能使用不同的网络协议、硬件、操作系统、编程语言等，导致数据交换和协作困难。解决异构性的方法有使用**中间件、移动代码**、虚拟机等。
2. **开放性**：分布式系统是否可以扩充或以不同的方式重新实现，取决于其公开的接口和协议。例如，RPC和Restful是两种不同的远程调用抽象方式。
3. **安全性**：分布式系统需要保护其资源和服务不受未经授权的访问、篡改和干扰，涉及到机密性、完整性和可用性三个方面。例如，使用ACL、加密、校验和、签名、防止拒绝服务攻击等技术。
4. **可伸缩性**：分布式系统需要在规模扩展后，保持良好的性能和可用性，避免资源耗尽和性能瓶颈。设计可伸缩的分布式系统需要考虑控制物理资源的代价、控制性能损失、控制软件资源被耗尽、防止性能瓶颈等方面。例如，使用DNS、缓存、复制、分区等技术。

:::note

什么是中间件？

中间件是一种软件，它提供基本的通信模块和其他一些基础服务模块，为应用程序开发提供平台。主要解决异构网络环境下分布式应用软件的互连与互操作问题，它可屏蔽实现细节，提高应用系统的易移植性。（进程间通信(RMI,RPC) +数据的外部表示，编码，RRP)
:::


## 第二章

### 2.1 分布式系统物理模型

从计算机和所用网络技术的特定细节中抽象出来的分布式系统底层硬件元素的表示。

### 2.2 分布式系统体系结构模型

#### 2.2.1 C/S、P2P两种不同结构

1. **C/S（客户－服务器）:** 客户直接和服务器连接，优点：简单、直接，缺点： 伸缩性差，系统的伸缩性不会超过提供服务的计算机的能力和该计算机所处网络连接的带宽。

![picture 0](images/a4b23927c8bb61a4d409975a5077135dd2aeb5bd39cc306728743b5035adde4f.png)  

2. **P2P（对等体系结构）:** 系统应用中，完全由对等进程组成，进程间的通信模式完全依赖于应用的需求。缺点是管理难度大。例子：Bittorrent、IPFS、eDonkey。

#### 2.2.2 分层模型、层次化模型

1. **分层模型**：将一个复杂的系统划分为若干层，每一层利用下一层提供的服务，同时向上一层提供服务。这种模式可以简化系统的设计和实现，提高系统的可维护性和可扩展性。分层模型中的每一层可以看作是一个服务层，提供一定的抽象和功能。例如，分布式系统中常见的分层模型有OSI七层模型、TCP/IP四层模型等。
2. **层次化模型**：与分层模型互补，是一种组织给定层功能的技术。层次化模型将一个服务层划分为多个水平的子层，每个子层可以部署在不同的物理节点上，实现功能的分布和并行。层次化模型可以提高系统的性能和可靠性，适应不同的应用需求和环境。层次化模型中的每个子层可以看作是一个服务层次，提供一定的服务质量和容错能力。例如，分布式系统中常见的层次化模型有Web应用。

![picture 1](images/bc53ebacf9907bce7cc3b7ace10ee1c2e0e4defd9b36a27a75fdc1a0bd32dfe9.png)  

### 2.3 交互、故障、安全三种基础模型

#### 2.3.1 交互模型

- **交互模型的概念**：分布式系统由多个以复杂方式进行交互的进程组成，进程之间通过消息传递进行交互，实现系统的通信和协作功能。
- **交互模型的影响因素**：通信性能和计算机时钟。通信性能包括延迟、带宽和抖动，计算机时钟包括时钟偏移和时钟校正。
- **交互模型的两个变体**：同步分布式系统（在线电子商务中的商品从订购到付款的过程）和异步分布式系统（例如Email、FTP、VOD）。同步分布式系统有严格的时间限制假设，异步分布式系统没有可预测的时限。异步分布式系统达成协定非常困难，例如Pepperland协定问题（两军问题的区别）。

#### 2.3.2 故障模型

**定义：** 定义故障发生的行为，帮助理解故障对分布式系统的影响。分为三种分类：
- **遗漏故障 Omission failures**：进程或者通信通道没有正常的工作，导致消息的丢失或者进程的崩溃。遗漏故障是良性故障，可以通过重传或者备份来恢复。
- **随机故障 Arbitrary failures**：进程或者通信通道的行为不可预测，可能产生错误的或者恶意的消息。随机故障是最严重的一种故障，对系统的影响最大，而且很难检测和纠正。
- **时序故障 Timing failures**：进程或者通信通道的行为受到时间因素的影响，可能导致消息的延迟或者乱序。时序故障是一种中间程度的故障，可以通过同步或者排序来解决。

#### 2.3.3 安全模型

分布式系统的模块特性和开放性，使他们暴露在内部或者外部的攻击下；

安全模型的目的是提供依据，以此分析系统可能受到的侵害，并在设计系统时防止这些侵害的发生；

## 第三章

### 3.1 时钟漂移及产生原因

时钟漂移是指物理时钟与理想时钟之间的偏差，即每个时钟的滴答速率与标准速率的差异。产生的原因主要有电源稳定性、环境温度等。

### 3.2 内部、外部物理时钟同步


- **内部物理时钟同步**：指的是在一个分布式系统中，所有的节点都尽量保持自己的物理时钟与某个参考时钟一致，或者至少保持时钟之间的偏差在一个可接受的范围内。
- **外部物理时钟同步**：指的是在一个分布式系统中，所有的节点都尽量保持自己的物理时钟与某个外部的标准时钟一致，例如国际原子时（TAI）或者协调世界时（UTC）。
- **物理时钟同步的目的**：是为了让分布式系统中的节点能够正确地协调和执行各种时间相关的任务，例如事件排序、共识算法、分布式事务、超时检测等。
- **物理时钟同步的方法**：有多种，例如基于消息传递的**Cristian算法**和**Berkeley算法**，以及基于网络广播的**NTP协议**和**PTP协议**。这些方法都有各自的优缺点，需要根据不同的场景和需求进行选择和优化。

### 3.3 时钟正确性含义

时钟正确性就是指物理时钟与理想时钟之间的偏差在一个可接受的范围内，即时钟的漂移率在一个可接受的范围内。

- 基于漂移率——漂移率在一个已知的范围内

$$
(1-\rho)\left(t^{\prime}-t\right) \leq H\left(t^{\prime}\right)-H(t) \leq(1+\rho)\left(t^{\prime}-t\right)
$$

- 基于单调性

$$
t^{\prime}>t \Rightarrow C\left(t^{\prime}\right)>C(t)
$$

- 基于混合条件： 单调性+漂移率有界+同步点跳跃前进

### 3.4 物理时钟同步的三种方法

#### 3.4.1 Cristian方法

Cristian方法是一种用于同步分布式系统中的物理时钟的算法。它的基本思想是：

- **客户端向服务器发送请求**：客户端选择一个可信的时间服务器，向它发送一个包含客户端当前时间的请求。
- **服务器回复客户端**：服务器收到请求后，将自己的当前时间作为回复发送给客户端。
- **客户端校正自己的时钟**：客户端收到回复后，计算请求和回复的往返时间，然后用服务器的时间加上往返时间的一半来更新自己的时钟。

Cristian方法的优点是简单易实现，缺点是需要网络延迟的稳定性和可预测性，以及服务器的可靠性和安全性。如果网络延迟变化很大，或者服务器被攻击或故障，那么客户端的时钟可能会出现较大的误差。

#### 3.4.2 Berkeley算法

这部分当前页面介绍了分布式系统中的时钟同步问题和Berkeley算法。Berkeley算法是一种适用于无法得知真实时间的分布式系统的时钟同步算法，其基本思想是：

- 选定一个**协调者**节点，负责收集其他**从属**节点的时钟信息，并计算出一个**平均**时间作为标准时间。
- 协调者节点将**平均**时间与自己的时钟进行比较，得出一个**时钟偏差**，并将其发送给所有从属节点。
- 从属节点根据收到的时钟偏差，对自己的时钟进行**调整**，使之与协调者节点的时钟保持一致。

Berkeley算法的优点是：

- 不需要物理时钟或广播通信，只需要协调者节点和从属节点之间的**点对点**通信。
- 能够处理**失效**节点和**消息延迟**，通过设置**超时**机制和**估计**网络延迟。
- 能够避免时钟**回拨**，即时钟向后调整，因为协调者节点只会发送时钟偏差，而不是绝对时间。

Berkeley算法的缺点是：

- 依赖于协调者节点的**可靠性**，如果协调者节点失效或被攻击，会影响整个系统的时钟同步。
- 需要协调者节点和从属节点之间的**频繁**通信，会增加网络开销和系统负载。
- 无法保证时钟的**精确性**，因为平均时间只是一个**近似**值，而不是真实时间。

#### 3.4.3 网络时间协议（NTP）

- **选择主节点**：网络中的一个节点被选为主节点，其它节点作为从节点。主节点从权威时钟源（如原子钟、GPS）接收精确的协调世界时（UTC）。
- **轮询从节点**：主节点定期轮询所有的从节点，询问它们的时间。此处可以使用克里斯丁算法（Cristian's algorithm）来计算网络延迟和时钟偏移。
- **计算平均值**：主节点根据从节点的时间和自己的时间，计算出一个平均时间，作为网络的标准时间。
- **发送偏移量**：主节点向每个从节点发送需要调整的时钟的偏移量，即从节点的时间与平均时间的差值。通过发送偏移量而不是时间戳来避免网络延迟的影响。
- **调整时钟**：从节点根据收到的偏移量，调整自己的时钟，使之与平均时间一致。这样，网络中的所有节点的时钟就达到了同步。


### 3.5 逻辑时间、逻辑时钟

逻辑时间和逻辑时钟是分布式系统中的重要概念。**在分布式系统中，由于不存在全局物理时间**，因此需要**使用逻辑时间来捕获分布式计算时间之间的因果关系**。逻辑时钟系统由一个时间域 T 和一个逻辑时钟 C 组成。时间域 T 上存在偏序关系 < ，这种关系表示事件发生优先或因果优先。逻辑时钟 C 是一个函数，该函数将分布式系统中的事件 e 映射到时间域 T ，得到的时间戳记为 C (e) 。逻辑时钟满足单调性，如事件 a 影响事件 b ，那么事件 a 的事件戳小于事件 b 。逻辑时钟系统框架定义了时钟一致性条件，即对任意两个事件 $e_i$ 和 $e_j$ ， $e_i \to e_j \Rightarrow C (e_i) < C (e_j)$ 。实现逻辑时钟需要解决两个问题：每个进程表示逻辑时间的数据结构和能够保证时钟一致性条件，用于更新数据结构的协议。

### 3.6 发生在先关系、并发关系及分布式系统中的事件排序

- **事件排序**：在分布式系统中，需要确定不同进程中发生的事件的先后顺序，以便协调和同步各个进程的行为。
- **先关系**：如果一个事件是由另一个事件直接或间接地引起的，那么这两个事件之间存在先关系，记为 **e -> e'**。先关系具有传递性、非对称性和非自反性的特点。
- **并发关系**：如果两个事件之间不存在先关系，那么这两个事件之间存在并发关系，记为 **e || e'**。并发关系表示两个事件是相互独立的，它们的发生顺序无法通过物理时钟或逻辑时钟来确定。

![picture 2](images/bf3ac27820422d602f523129803e05c94f763e5f869fb7b5838be78ed5e71baa.png)  

a→b、c→d 和 e→f成立 b→c 和 d→f成立 b→d、b→f 和 c→f均成立 事件b和e无法比较，即 b||e。

### 3.7 Lamport时钟、全序逻辑时钟及向量时钟

#### 3.7.1 全序逻辑时钟

Lamport时钟是一种逻辑时钟，用于确定分布式系统中事件的因果顺序。它是由**Leslie Lamport**于1978年提出的。Lamport时钟的基本思想是：

- 每个进程维护一个本地计数器，称为**Lamport时间戳**，初始为0。
- 每当一个进程执行一个**内部事件**，它就将其时间戳加1。
- 每当一个进程发送一个**消息**，它就将其时间戳加1，并将该时间戳作为**消息时间戳**附加到消息中。
- 每当一个进程接收一个**消息**，它就将其时间戳更新为**最大值**（自己的时间戳，消息时间戳）+1，并执行**接收事件**。

Lamport时钟的性质是：

- 如果事件a在事件b之前发生（因果顺序），那么Lamport时间戳(a) < Lamport时间戳(b)。
- 如果Lamport时间戳(a) < Lamport时间戳(b)，那么事件a可能在事件b之前发生，也可能与事件b同时发生（并发顺序）。
- Lamport时钟不能区分并发事件的顺序，只能保证因果事件的顺序。

![picture 3](images/b58426f93a89941ed8e198ce296d0ce91e4a4689dea0a483f182063a2f7ff2f6.png)  

不同进程产生的消息可能具有相同数值的Lamport时间戳

![picture 4](images/2c7d2fa014a98d8464f9d57e28d23947be8bb399a5ec25dc0e90754606b73ff8.png)  

练习：假设系统中只存在消息发送和接收事件，如下图所示，请给出事件a-g的逻辑时钟。

![picture 5](images/40dd0130750d832028438232d164f1066bcd67a134836e8ab0281f4c64311093.png)  


#### 3.7.3 全序逻辑时钟

全序逻辑时钟是一种用于确定分布式系统中事件的全局顺序的方法。它的基本思想是：

- 每个进程维护一个逻辑时钟，初始为零，每执行一个事件就加一。
- 每个进程在发送消息时，将自己的逻辑时钟值附加到消息中。
- 每个进程在接收消息时，将自己的逻辑时钟更新为自己的逻辑时钟和消息中的逻辑时钟的较大者，然后再加一。
- 两个事件的全序关系由它们的逻辑时钟值和所属进程的标识符决定。如果两个事件的逻辑时钟值不同，那么逻辑时钟值较小的事件先于逻辑时钟值较大的事件。如果两个事件的逻辑时钟值相同，那么所属进程的标识符较小的事件先于所属进程的标识符较大的事件。

全序逻辑时钟的优点是简单、有效，不需要物理时钟的同步。它的缺点是可能与物理时间不一致，且需要每个进程的标识符是唯一的。

![picture 6](images/4f3e859283e5d5d9feaf57cd48cb2e618cbdb72fdb9e6021ab0ff67d237de1ea.png)  



#### 3.7.4 向量时钟

向量时钟是一种用于表示逻辑时间和事件顺序的方法，它可以解决物理时钟的不准确和不一致的问题。向量时钟的基本思想是，每个进程维护一个向量，其中包含了它自己和其他进程的逻辑时钟值。每当一个进程发生一个内部事件或者发送消息时，它就会增加自己的逻辑时钟值。每当一个进程接收消息时，它就会更新自己的向量，使之不小于自己和消息中的向量。向量时钟可以用于判断两个事件的因果关系，即如果一个事件的向量小于另一个事件的向量，那么它就发生在另一个事件之前；如果两个事件的向量无法比较，那么它们就是并发的。向量时钟可以帮助分布式系统实现全局状态的检测和分布式调试的功能。

![picture 7](images/a748c28ec286f104fb33d2c43e41df29de2b268f570982a85ab8e51b159b2451.png)  

:::tip

物理意义何在？观察到的对应进程的最新状态，有全局信息。
Lamport时钟只有部分全局信息。

:::

练习：假设系统中只存在消息发送和接收事件，如下图所示，请给出事件a-g的向量时钟。

![picture 8](images/2850a95f44d84e57d5b066e10ce82f0cbef5927e2792457be7583f4510885afb.png)  

:::tip

如果有汇聚的情况，取每个进程的最大值。

:::


### 3.8 割集、割集的一致性、一致的全局状态概念


根据当前页面的内容，割集（cut）是一种划分分布式系统中的进程集合的方法，它可以用来描述系统的全局状态。割集有以下几个特点：

- **一致性**：割集中的每个进程的状态都是在同一个逻辑时刻或之前的状态，即不存在因果依赖的状态。
- **完整性**：割集中的每个进程的状态都是由该进程发送或接收的最后一条消息决定的，即不存在未完成的消息传递。
- **可达性**：割集中的任意两个进程之间都存在一条或多条消息传递的路径，即不存在孤立的进程。

割集可以用来捕捉分布式系统的快照，即系统在某一时刻的全局状态。快照可以用来检测系统的属性，如死锁、终止、全局谓词等。快照算法的目标是在不影响系统正常运行的情况下，找到一个一致的割集，并记录割集中的每个进程的状态和通道的消息。



### 3.9 一致的全局状态


- **一致的全局状态**：一个分布式系统中的所有进程在某一时刻的状态的集合，称为该系统的**全局状态**。如果一个全局状态是由一个**切向面**划分的，即每个进程的状态都是在同一个逻辑时刻发生的，那么这个全局状态是**一致的**。
- **切向面**：一个切向面是一个分布式系统中的所有进程的状态的分割线，它可以用来表示一个全局状态。一个切向面可以是**平凡的**，即它包含所有进程的初始或最终状态，也可以是**非平凡的**，即它包含一些进程的中间状态。
- **切向面的性质**：一个切向面的性质取决于它是否包含了**因果依赖**的违反。如果一个切向面没有因果依赖的违反，即它不包含任何从右向左穿过的消息，那么这个切向面是**一致的**。如果一个切向面有因果依赖的违反，即它包含至少一个从右向左穿过的消息，那么这个切向面是**不一致的**。
- **切向面的应用**：切向面可以用来检测分布式系统中的**死锁**，**终止**，**快照**等性质。通过构造和分析切向面，可以确定一个分布式系统的全局状态是否满足某些条件。

算法示例

- 两个进程p1、p2进行交易，每件\$10
- 初始状态:进程p2已经收到5件商品的定单，它将马上发送商品给p1。p1又将订购10个。

![picture 9](images/3cfc1d869defd8b2b4f8968d9fc43922aebce477ed275aa8cf87833307791e22.png)  

![picture 11](images/c879642243a550c9964c0e8a20274f5984879410924b5e7ad2c01de568860428.png)  





