# 高级算法设计与分析

## 一、稳定匹配问题

稳定匹配问题是指在一个匹配问题中，如果不存在一个男生和一个女生，他们彼此喜欢对方胜过自己现在的伴侣，那么这个匹配就是稳定的。

但是，稳定匹配问题并不是所有的匹配问题都有解，而且即使有解，也不一定是唯一的。为了解决这个问题，Gale和Shapley提出了一个算法，可以在多项式时间内找到一个稳定匹配。这个算法就叫做Gale-Shapley算法（GS算法）。

### GS算法

GS算法的基本思想是，每个男生都会向他最喜欢的女生求婚，每个女生都会拒绝她最不喜欢的男生，直到每个女生都有了自己的伴侣。

下面是GS算法的伪代码：

```cpp
while (存在没有伴侣的男生m) {
    令w是m最喜欢的没有求婚过的女生
    if (w没有伴侣) {
        (m, w)成为一对
    } else {
        // w有伴侣m'
        if (w更喜欢m的求婚者m') {
            (m, w)成为一对
            m'变成没有伴侣
        } else {
            (m, w)不成为一对
        }
    }
}
```

如何证明这个算法得到的结果是稳定的呢？我们可以用反证法来证明。下面我们用反证法来证明GS算法得到的结果是稳定的。

问题陈述： 假设我们有一对稳定婚姻问题，使用GS算法求解后，没有稳定的匹配。

步骤 1：构造反例匹配

首先，我们假设GS算法的输出没有稳定的匹配。这意味着存在一对男性和女性，他们不是当前匹配的一对，但他们可以互相更喜欢对方而不满意目前的匹配。设想这对男性为M1和女性为W1。

情况1，M1 从来没有和 W1 求过婚：

如果 M1 从来没有和 W1 求过婚，那么 W1 一定是在 GS 算法的某一轮中拒绝了 > 1 的求婚。这意味着 W1 当前有一个伴侣 M2，且 W1 更喜欢 M2 而不是 M1。但是，这意味着 M2 也更喜欢 W1 而不是 W2，这就意味着 M2 和 W1 会在 GS 算法的某一轮中成为一对，这就与我们的假设矛盾了。

情况2，M1 曾经和 W1 求过婚：

如果 M1 曾经和 W1 求过婚，那么 W1 一定是在 GS 算法的某一轮中拒绝了 M1 的求婚。这意味着 W1 当前有一个伴侣 M2，且 W1 更喜欢 M2 而不是 M1。但是，这意味着 M2 也更喜欢 W1 而不是 W2，这就意味着 M2 和 W1 会在 GS 算法的某一轮中成为一对，这就与我们的假设矛盾了。

所以，我们可以得出结论，GS算法的输出是稳定的。

> 思考：对于一个匹配问题，可能会有多个稳定的匹配，那么GS算法得到的结果是不是唯一的呢？如果是的话，是哪一个呢？


定义：男生m是女生w的一个有效伴侣，如果存在一个稳定匹配，其中m和w是一对。

> Man-optimal assignment. 每个男孩的伴侣找到的都是自己最优的伴侣


假设男生A找到的伴侣B不是他的最优伴侣，而是C。这意味着在A的偏好列表中，C在B之前，并且A在C的偏好列表中也在B之前。否则，如果C在A的偏好列表中排在B之后，那么GS算法会先分配B给A，而不是C。

现在考虑女生B，她的当前伴侣是A，但是她的最优伴侣是男生C。这也意味着在B的偏好列表中，C在A之前，而且C在B的偏好列表中也在A之前。这与我们之前的假设相矛盾，因为GS算法确保了男生A的选择是有限的，他会在选择B之后选择C，因为C在A的偏好列表中排在B之前。

因此，根据反证法，我们的假设是错误的，男生A找到的伴侣B必须是他的最优伴侣。同样的逻辑可以应用于所有男生，证明GS算法中男生找到的伴侣都是他们的最优伴侣。

因此，我们可以得出结论：GS算法中男生找到的伴侣都是最优伴侣。


课上给的证明方法：

声明：GS匹配S*是男性最优的。
证明（反证法）：
- 假设某个男性与不是他最佳伴侣的人配对。男性按偏好递减的顺序提出求婚，因此某个男性被一个合法的伴侣拒绝。
- 让Y是第一个被拒绝的男性，A是第一个拒绝他的合法女性。
- 令S是一个稳定匹配，其中A和Y被配对。
- 当Y被拒绝时，A与她更喜欢的男性Z建立（或重申）婚约。
- 令B是S中Z的伴侣。
- 在Y被A拒绝时，Z没有被任何合法的伴侣拒绝。因此，Z更喜欢A而不是B。
- 但A更喜欢Z而不是Y，由于一个合法的伴侣。
- 因此，在S中A-Z是不稳定的。

### 匹配问题拓展

男孩女孩匹配问题的拓展：

1. 男孩和女孩的数量不一定相等
2. 男孩和女孩的偏好列表长度不一定相等
3. 一个男孩可能匹配多个女孩

这些问题有时候GS算法无法解决，比如对于第三个问题，GS算法无法解决，但是我们可以对GS算法进行拓展。比如一个男孩可以匹配三个女生的时候，我们可以把这个男孩复制两份，然后分别匹配三个女孩，这样就可以用GS算法解决了。

## 二、算法设计与分析基础

### 渐进分析

渐进分析中有五个重要的渐进符号：

1. 大O符号：O(f(n))表示一个函数的渐进上界
2. 大Ω符号：Ω(f(n))表示一个函数的渐进下界
3. 大Θ符号：Θ(f(n))表示一个函数的渐进紧密界
4. 小o符号：o(f(n))表示一个函数的渐进非紧密上界
5. 小ω符号：ω(f(n))表示一个函数的渐进非紧密下界

渐进分析的目的是找到一个函数，它可以描述算法的运行时间。这个函数的形式是：T(n) = O(f(n))，其中T(n)是算法的运行时间，f(n)是一个函数。

下面详细解释一下这五个符号：

举个例子，假设我们有一个函数 f(n) = 3n^2 + 2n + 1，那么O(f(n)) = O(n^2)。因为当n趋近于无穷大的时候，3n^2 + 2n + 1的增长速度和n^2的增长速度是一样的，所以我们可以说3n^2 + 2n + 1的渐进上界是n^2。

还需要注意，f(n) 可以属于 O(n^2)，同时也可以属于 O(n^3)，因为 O(n^2) 和 O(n^3) 都是 f(n) 的渐进上界。

但是他不属于 O(n)，因为 O(n) 不是 f(n) 的渐进上界。


### 三个算法设计思想

#### 1. 贪心算法

贪心算法的基本思想是，每一步都选择当前状态下最好的选择，最终得到的结果就是全局最优的结果。举一个例子，假设我们要找零钱，我们可以每次都选择面值最大的硬币，最终得到的结果就是最少的硬币数量。

贪心算法是一种局部最优的算法，它不一定能得到全局最优的结果。他的优点是简单、有效。缺点是可能得不到全局最优的结果。

「课堂例题」 时间间隔调度问题是一个经典的贪心算法问题。假设我们有一些任务，每个任务都有一个开始时间和结束时间，我们要找到一种调度方式，使得每个时间点都有最多的任务在执行。这个问题的解决方法是，每次都选择结束时间最早的任务，然后将这个任务从任务列表中删除，直到任务列表为空。

除了选择结束时间最早的任务，我们还可以选择开始时间最早的任务，这种方法也可以得到最优的结果。但是如果我们选择执行时间最短的任务，那么就不能得到最优的结果了。

**贪心算法的证明：**

为什么选择结束时间最早的任务可以得到最优的结果呢？我们可以用反证法来证明。

1. 假设我们选择的任务列表不是最优的
2. 假设 a1, a2, a3, ..., an 是贪心算法选择的任务列表
3. 假设b1, b2, b3, ..., bn 是最优的任务列表
4. 其中 a1=b1, a2=b2, a3=b3, ..., ak=bk，但是 ak+1 != bk+1
5. 由于 ak+1 != bk+1，所以 ak+1 的结束时间一定比 bk+1 的结束时间晚
6. 但是贪心算法每一步都选择结束时间最早的任务，所以 ak+1 的结束时间一定比 bk+1 的结束时间早
7. 这与 ak+1 的结束时间一定比 bk+1 的结束时间晚相矛盾
8. 所以假设不成立，贪心算法选择的任务列表是最优的

同样的也可以证明选择开始时间最早的任务的方法也可以得到最优的结果。

**时间分析：**

我们可以用贪心算法来解决时间间隔调度问题，但是我们还需要分析一下这个算法的时间复杂度。

我们可以将这个算法分成两个步骤，第一个步骤是对任务列表进行排序，第二个步骤是选择任务。第一个步骤的时间复杂度是O(nlogn)，第二个步骤的时间复杂度是O(n)，所以这个算法的时间复杂度是O(nlogn)。

「课堂例题」硬币找零问题是一个经典的贪心算法问题。假设我们有一些硬币，每个硬币的面值都是5的倍数，我们要找零钱，使得硬币的数量最少。这个问题的解决方法是，每次都选择面值最大的硬币，然后将这个硬币从硬币列表中删除，直到硬币列表为空。

和硬币找零类似的一个经典问题是邮票问题，这些邮票的面值是1,10,21,34,70,100,350,1225,1500。我们要找到一种方法来找到1400分的邮票，使得邮票的数量最少。

这个时候如果用贪心算法，那么我们得到的结果就是100,34,1,1,1,1,1。但其实最优结果是70,70。所以贪心算法并不是所有的问题都能得到最优的结果。

为什么硬币问题可以用贪心算法得到最优的结果，而邮票问题不能呢？这是因为硬币的面值是5的倍数，所以我们每次都可以选择面值最大的硬币，而邮票的面值不是5的倍数，所以我们不能每次都选择面值最大的邮票。

#### 2. 分治算法

分治算法的基本思想是，将一个大问题分解成若干个小问题，然后将这些小问题的解合并起来，得到大问题的解。举一个例子，假设我们要对一个数组进行排序，我们可以将这个数组分成两个子数组，然后分别对这两个子数组进行排序，最后将这两个子数组合并起来，得到一个有序的数组。这个算法就是归并排序。

两数相加问题可以用分治算法来解决。 假设我们有两个n位的二进制数，我们要计算这两个二进制数的和。这个问题的解决方法是，将这两个二进制数分成两半，然后分别计算这两个二进制数的前一半和后一半，最后将这两个结果合并起来，得到最终的结果。对于已经分成两半的二进制数，我们可以继续分成两半，直到分成的二进制数只有一位。 

#### 3. 动态规划

动态规划的基本思想是，将一个大问题分解成若干个小问题，然后将这些小问题的解合并起来，得到大问题的解。这个思想和分治算法的思想是一样的，但是动态规划和分治算法的区别在于，动态规划会将子问题的解保存起来，避免重复计算。举一个例子，假设我们要计算斐波那契数列的第n项，我们可以将这个问题分解成计算第n-1项和第n-2项，然后将这两个项的和作为第n项的值。但是如果我们使用分治算法，那么我们会重复计算第n-2项，因为第n-2项是第n-1项的子问题，而第n-1项又是第n项的子问题。

前面我们提到过时间间隔调度问题，如果给每个工作给定一个权重，我们要找到一种调度方式，使得规定时间内完成工作的权重最大。这个时候就不能用贪心的方法来解决这种问题了，我们可以用动态规划来解决这个问题。

动态规划的基本思想是，将一个大问题分解成若干个小问题，然后将这些小问题的解合并起来，得到大问题的解。这个思想和分治算法的思想是一样的，但是动态规划和分治算法的区别在于，动态规划会将子问题的解保存起来，避免重复计算。如果用动态规划来解决带权重的时间间隔调度问题，那么我们需要用一个数组来保存每个时间点的最优解，这样就可以避免重复计算。

下列代码是用动态规划来解决带权重的时间间隔调度问题的代码：

```cpp
// jobs是一个数组，每个元素是一个数组，包含三个元素，分别是开始时间、结束时间和权重

int maxWeight(vector<vector<int>> jobs) {
    // 找到最大的结束时间
    int maxEndTime = 0;
    for (int i = 0; i < jobs.size(); i++) {
        maxEndTime = max(maxEndTime, jobs[i][1]);
    }

    // 初始化dp数组
    vector<int> dp(maxEndTime + 1, 0);

    // 计算dp数组
    for (int i = 1; i <= maxEndTime; i++) {
        dp[i] = dp[i - 1];
        for (int j = 0; j < jobs.size(); j++) {
            if (jobs[j][1] == i) {
                dp[i] = max(dp[i], dp[jobs[j][0]] + jobs[j][2]);
            }
        }
    }

    return dp[maxEndTime];
}
```

上面代码的时间复杂度为O(n^2)，空间复杂度为O(n)。

对于每一个时间节点，都可以分为两种情况，一种是这个时间节点不做任务，另一种是这个时间节点做任务。如果这个时间节点不做任务，那么这个时间节点的最优解就是前一个时间节点的最优解。如果这个时间节点做任务，那么这个时间节点的最优解就是这个任务的权重加上这个任务开始时间前的最优解。所以这个时间节点的最优解就是这两种情况中的最大值。这样我们就可以得到一个递推公式，然后用这个递推公式来计算dp数组。

**数学表达：**

![picture 0](images/95f6f20c5d08e6648605b57c21a6d92853d39f8e47b6f92699a8aba6efe70263.png)

:::tip

*什么是设计动态规划算法最重要的步骤：

1. 构造子问题：将原问题分解成若干个子问题
2. 构建递归关系式：将子问题的解合并起来，得到原问题的解
3. 求解：计算子问题的解，然后计算原问题的解

在写作业或者考试的时候，如果遇到动态规划的问题，一定要按照这三个步骤来解决问题。就是按照这三个步骤来给分的。

:::


**背包问题：**

背包问题是一个经典的动态规划问题。假设我们有一个背包，背包的容量是C，我们有n个物品，每个物品的重量是w1, w2, w3, ..., wn，每个物品的价值是v1, v2, v3, ..., vn。我们要找到一种装法，使得背包中物品的总价值最大。

首先第一步是构造子问题，我们可以将这个问题分解成n个子问题，每个子问题是：在选了前i个物品的情况下，背包的容量是C，这种情况下背包中物品的总价值最大是多少。这个子问题的解记为f(i, C)。

第二步骤是构建递归关系式，我们可以得到这样一个递推公式, 包含3种情况：

$$
f(i, C) = \begin{cases}
0 & i = 0 \text{ or } C = 0 \\
f(i-1, C) & w_i > C \\
max(f(i-1, C), v_i + f(i-1, C-w_i)) & otherwise
\end{cases}
$$

这个公式的理解是，如果我们不选第i个物品，那么背包中物品的总价值就是前i-1个物品的总价值。如果我们选了第i个物品，那么背包中物品的总价值就是第i个物品的价值加上前i-1个物品在剩余容量为C-wi的背包中的总价值。

第三步骤是求解，我们可以用递归的方法来求解这个问题，也可以用迭代的方法来求解这个问题。用迭代的方式解决的思路是，我们先计算出f(0, 0), f(0, 1), f(0, 2), ..., f(0, C)，然后计算出f(1, 0), f(1, 1), f(1, 2), ..., f(1, C)，然后计算出f(2, 0), f(2, 1), f(2, 2), ..., f(2, C)，一直计算到f(n, 0), f(n, 1), f(n, 2), ..., f(n, C)。最后我们就可以得到f(n, C)。

下面是用迭代的方式来解决背包问题的代码：

```cpp
int knapsack(vector<int> w, vector<int> v, int C) {
    // 初始化dp数组
    vector<vector<int>> dp(w.size() + 1, vector<int>(C + 1, 0));

    // 计算dp数组
    for (int i = 1; i <= w.size(); i++) {
        for (int j = 0; j <= C; j++) {
            dp[i][j] = dp[i - 1][j];
            // 如果当前背包的容量可以放下第i个物品，
            // 那么我们就需要考虑一下是否放入第i个物品
            if (j >= w[i - 1]) {
                // 如果放入第i个物品，那么总价值是
                // v[i-1] + dp[i-1][j-w[i-1]]
                dp[i][j] = max(dp[i][j], v[i - 1] + dp[i - 1][j - w[i - 1]]);
            }
        }
    }
    // 返回最后一个格子的值
    return dp[w.size()][C];
}
```


**序列比对：**

序列比对（Sequence Alignment）是一个经典的动态规划问题。假设我们有两个序列，一个是A，一个是B，我们要找到A和B的最长公共子序列。这个问题的解决方法是，我们可以将A和B分别分成两个子序列，然后分别比较这两个子序列，最后将这两个子序列合并起来，得到A和B的最长公共子序列。

第一步是构造子问题，我们可以将这个问题分解成n*m个子问题，每个子问题是：在A的前i个字符和B的前j个字符的情况下，A和B的最长公共子序列的长度是多少。这个子问题的解记为f(i, j)。

第二步是构建递归关系式，我们可以得到这样一个递推公式, 包含3种情况：

$$
f(i, j) = \begin{cases}
0 & i = 0 \text{ or } j = 0 \\
f(i-1, j-1) + 1 & A[i] = B[j] \\
max(f(i-1, j), f(i, j-1)) & otherwise
\end{cases}
$$

第三步是求解，可以用迭代的方法来求解这个问题。

下面是用迭代的方式来解决序列比对问题的代码：

```cpp
#include <iostream>

using namespace std;

const int N = 1010;

char a[N],b[N];
int f[N][N];
int n,m;

int main()
{
    cin >> n >> m;
    scanf("%s%s",a+1,b+1);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            if(a[i] == b[j]) f[i][j] = f[i-1][j-1]+1;
            else f[i][j] = max(f[i-1][j],f[i][j-1]);
        }
    cout << f[n][m];
}
```























